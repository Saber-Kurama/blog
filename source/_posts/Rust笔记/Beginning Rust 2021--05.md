---
 title: Rust 2021 版入门
 date: 2022-01-16
 tag: rust
---
# rust

## Allocating Memory (分配内存)

* The various kinds of memory allocation, their performance characteristics, and their limitations (各种内存分配、它们的性能特征和局限性)
* How to specify in Rust which memory allocation to use for an object (如何在 Rust 中指定用于对象的内存分配)
* The difference between a reference and a Box (reference和 Box之间的区别)

### The Various Kinds of Allocation (各种分配)

要理解 Rust 语言，以及任何其他系统编程语言，如 C 语言，重要的是理解内存分配的各种概念，如静态分配、堆栈分配和堆分配。
本章完全致力于这些问题。特别是，我们将看到四种内存分配：
* In processor registers   在处理器寄存器中
* Static  静态分配
* In the stack  在栈中
* In the heap 在堆中

在 C 和 C++ 语言中，静态分配是全局变量和使用 static 关键字声明的变量的分配；堆栈分配用于所有非静态局部变量，也用于函数参数；而堆分配是通过调用 C 语言标准库的 malloc 函数或 C++ 语言的 new 运算符来使用的。

### Linear Addressing 线性寻址
在任何计算机硬件中，都有一种可读写的内存，也称为 RAM，它由一长串字节组成，可以通过它们的位置访问。内存的第一个字节的位置为零，而最后一个字节的位置等于已安装内存的大小减一。
简而言之，在我们这个时代有两种计算机：
* Those where a single process at a time can run, and where such a process directly uses the physical memory addresses. These are called real-memory systems . （那些一次可以运行一个进程，并且这样的进程直接使用物理内存地址的地方。这些被称为实内存系统。）
* Those with a multiprogramming operating system, which offers a virtual address space to each of the running processes. These are called virtual-memory systems （那些拥有多道程序操作系统的人，它为每个正在运行的进程提供了一个虚拟地址空间。这些被称为虚拟内存系统）

在第一类计算机中，现在仅用作控制器，可能没有操作系统（因此它们也被称为裸机系统），或者可能有一个操作系统驻留在内存的第一部分.在最后一种情况下，应用程序可以使用大于某个值的地址。

在第二种计算机中，访问系统内存的任何部分的能力是为操作系统保留的，它以特权模式（也称为保护模式或内核模式）运行，并且此类软件分配部分内存到各种正在运行的进程。

然而，在多道程序系统中，进程对内存的看法与操作系统对内存的看法不同。考虑一下：一个进程请求操作系统允许使用更多的 200 个内存字节，并且操作系统通过为该进程保留（例如，从机器位置 300 到机器位置 499 的内存部分，包括极端情况）来满足这样的请求。然后操作系统通知进程它已经分配了 200 个字节，但它没有通知它这部分内存的起始地址是 300。实际上，每个进程都有一个不同的地址空间，正确地称为虚拟地址空间，操作系统映射到物理内存，恰当地称为真实内存。

实际上，当一个进程向操作系统请求一些内存时，操作系统只是保留了该进程的一部分地址空间，并没有真正为该进程保留真正的内存。因此，即使对于非常大的内存部分，这种分配也非常快。

只要进程试图访问这样的内存，即使只是将其初始化为零，操作系统就会意识到该进程正在访问尚未映射到真实内存的部分虚拟内存；它立即将访问的虚拟内存部分映射到相应的实内存部分。

因此，进程并不直接在真实内存上运行，而是在操作系统为它们提供的虚拟内存上运行，并且它已映射到真实内存。

事实上，通常单个进程的虚拟内存甚至比计算机的整个真实内存还要大。例如，您可以拥有一台具有 1 GB 物理（实际）内存的计算机，并在该计算机上运行四个进程，每个进程具有 3 GB 的虚拟内存空间。如果所有虚拟内存都映射到实际内存，则需要 12 GB 的内存来处理这种情况。相反，虚拟内存的大部分字节都没有映射到真实内存；只有进程实际使用的字节才会映射到实际内存。只要进程开始使用其地址空间中尚未映射到真实内存的部分，操作系统就会将虚拟内存的这些部分映射到真实内存的相应部分。

因此，每当一个进程为了读取或写入而访问一个地址时，如果该地址属于保留的虚拟内存部分（称为页面）并映射到实际内存的相应部分，则该进程会立即访问该实际内存。相反，如果该页面被保留但当前未映射，则操作系统在允许此类访问之前以一种称为页面错误的机制启动，通过该机制分配一个实际内存页面并将该页面映射到所引用的虚拟内存页面通过访问的地址。但是，如果访问的地址不属于操作系统保留的作为进程地址空间一部分的页面，则会发生寻址错误（通常称为分段错误）。这在用 Rust 或更高级别语言（如 Java、JavaScript 或 Python）编写的程序中非常罕见，因为这些语言中的语句只能访问先前为进程保留的内存。相反，这种错误在汇编和 C 等低级语言中很常见，因为在此类语言中，任何数字都可以转换为内存地址，如果地址计算错误，它可能在内存地址空间之外。程序。通常，解决错误会导致流程立即终止。

当然，如果程序过度使用内存，操作系统可能会花费大量时间来进行此类映射，从而导致进程大幅减慢，甚至因内存不足而终止。

因此，在现代计算机中，无论是单程序计算机还是多程序计算机，每个进程都将其内存视为字节数组。一种情况是真实内存，另一种情况是虚拟内存；无论如何，它是一个连续的地址空间，或者，通常所说的，使用线性寻址。这与使用分段地址空间的旧计算机系统不同，应用程序程序员使用起来更加麻烦

所有这一切都说明了，在虚拟内存系统中，操作系统管理一种内存分配，即从虚拟内存到真实内存的映射。不过，从现在开始，我们将不再谈论这种内存分配，我们将内存分配定义为保留进程看到的一部分内存，并将这部分内存与 Rust 对象相关联的操作。

###  Static Allocation 静态分配
不过，有各种分配政策。


