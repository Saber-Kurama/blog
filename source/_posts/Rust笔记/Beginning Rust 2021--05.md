---
 title: Rust 2021 版入门
 date: 2022-01-16
 tag: rust
---
# rust

## Allocating Memory (分配内存)

* The various kinds of memory allocation, their performance characteristics, and their limitations (各种内存分配、它们的性能特征和局限性)
* How to specify in Rust which memory allocation to use for an object (如何在 Rust 中指定用于对象的内存分配)
* The difference between a reference and a Box (reference和 Box之间的区别)

### The Various Kinds of Allocation (各种分配)

要理解 Rust 语言，以及任何其他系统编程语言，如 C 语言，重要的是理解内存分配的各种概念，如静态分配、堆栈分配和堆分配。
本章完全致力于这些问题。特别是，我们将看到四种内存分配：
* In processor registers   在处理器寄存器中
* Static  静态分配
* In the stack  在栈中
* In the heap 在堆中

在 C 和 C++ 语言中，静态分配是全局变量和使用 static 关键字声明的变量的分配；堆栈分配用于所有非静态局部变量，也用于函数参数；而堆分配是通过调用 C 语言标准库的 malloc 函数或 C++ 语言的 new 运算符来使用的。

### Linear Addressing 线性寻址
在任何计算机硬件中，都有一种可读写的内存，也称为 RAM，它由一长串字节组成，可以通过它们的位置访问。内存的第一个字节的位置为零，而最后一个字节的位置等于已安装内存的大小减一。
简而言之，在我们这个时代有两种计算机：
* Those where a single process at a time can run, and where such a process directly uses the physical memory addresses. These are called real-memory systems . （那些一次可以运行一个进程，并且这样的进程直接使用物理内存地址的地方。这些被称为实内存系统。）
* Those with a multiprogramming operating system, which offers a virtual address space to each of the running processes. These are called virtual-memory systems （那些拥有多道程序操作系统的人，它为每个正在运行的进程提供了一个虚拟地址空间。这些被称为虚拟内存系统）

在第一类计算机中，现在仅用作控制器，可能没有操作系统（因此它们也被称为裸机系统），或者可能有一个操作系统驻留在内存的第一部分.在最后一种情况下，应用程序可以使用大于某个值的地址。

在第二种计算机中，访问系统内存的任何部分的能力是为操作系统保留的，它以特权模式（也称为保护模式或内核模式）运行，并且此类软件分配部分内存到各种正在运行的进程。

然而，在多道程序系统中，进程对内存的看法与操作系统对内存的看法不同。考虑一下：一个进程请求操作系统允许使用更多的 200 个内存字节，并且操作系统通过为该进程保留（例如，从机器位置 300 到机器位置 499 的内存部分，包括极端情况）来满足这样的请求。然后操作系统通知进程它已经分配了 200 个字节，但它没有通知它这部分内存的起始地址是 300。实际上，每个进程都有一个不同的地址空间，正确地称为虚拟地址空间，操作系统映射到物理内存，恰当地称为真实内存。

实际上，当一个进程向操作系统请求一些内存时，操作系统只是保留了该进程的一部分地址空间，并没有真正为该进程保留真正的内存。因此，即使对于非常大的内存部分，这种分配也非常快。

只要进程试图访问这样的内存，即使只是将其初始化为零，操作系统就会意识到该进程正在访问尚未映射到真实内存的部分虚拟内存；它立即将访问的虚拟内存部分映射到相应的实内存部分。

因此，进程并不直接在真实内存上运行，而是在操作系统为它们提供的虚拟内存上运行，并且它已映射到真实内存。

事实上，通常单个进程的虚拟内存甚至比计算机的整个真实内存还要大。例如，您可以拥有一台具有 1 GB 物理（实际）内存的计算机，并在该计算机上运行四个进程，每个进程具有 3 GB 的虚拟内存空间。如果所有虚拟内存都映射到实际内存，则需要 12 GB 的内存来处理这种情况。相反，虚拟内存的大部分字节都没有映射到真实内存；只有进程实际使用的字节才会映射到实际内存。只要进程开始使用其地址空间中尚未映射到真实内存的部分，操作系统就会将虚拟内存的这些部分映射到真实内存的相应部分。

因此，每当一个进程为了读取或写入而访问一个地址时，如果该地址属于保留的虚拟内存部分（称为页面）并映射到实际内存的相应部分，则该进程会立即访问该实际内存。相反，如果该页面被保留但当前未映射，则操作系统在允许此类访问之前以一种称为页面错误的机制启动，通过该机制分配一个实际内存页面并将该页面映射到所引用的虚拟内存页面通过访问的地址。但是，如果访问的地址不属于操作系统保留的作为进程地址空间一部分的页面，则会发生寻址错误（通常称为分段错误）。这在用 Rust 或更高级别语言（如 Java、JavaScript 或 Python）编写的程序中非常罕见，因为这些语言中的语句只能访问先前为进程保留的内存。相反，这种错误在汇编和 C 等低级语言中很常见，因为在此类语言中，任何数字都可以转换为内存地址，如果地址计算错误，它可能在内存地址空间之外。程序。通常，解决错误会导致流程立即终止。

当然，如果程序过度使用内存，操作系统可能会花费大量时间来进行此类映射，从而导致进程大幅减慢，甚至因内存不足而终止。

因此，在现代计算机中，无论是单程序计算机还是多程序计算机，每个进程都将其内存视为字节数组。一种情况是真实内存，另一种情况是虚拟内存；无论如何，它是一个连续的地址空间，或者，通常所说的，使用线性寻址。这与使用分段地址空间的旧计算机系统不同，应用程序程序员使用起来更加麻烦

所有这一切都说明了，在虚拟内存系统中，操作系统管理一种内存分配，即从虚拟内存到真实内存的映射。不过，从现在开始，我们将不再谈论这种内存分配，我们将内存分配定义为保留进程看到的一部分内存，并将这部分内存与 Rust 对象相关联的操作。

###  Static Allocation 静态分配
不过，有各种分配政策。
最简单的分配策略是静态分配。根据该策略，编译器确定程序对象需要多少字节，并从地址空间中获取相应的字节序列。所有静态分配的对象都是连续布局的。因此，每个变量的地址是在编译时确定的。这是 Rust 中的一个示例：

``` rust
static _A: u32 = 3;
static _B: i32 = -1_000_000;
static _C: f64 = 5.7e10;
static _D: u8 = 200;
```
`static` 关键字类似于 let 关键字。两者都用于声明变量并可选地对其进行初始化
static 和 let 的区别在于
* static 使用静态分配，而 let 使用堆栈分配，下一节介绍。
* static 需要明确指定变量的类型，使用 let 是可选的。
* 普通代码无法更改静态变量的值，即使它具有 mut 规范。因此，在 Rust 中，出于安全原因，静态变量通常是不可变的。
* 样式指南要求静态变量的名称只能包含大写字母，单词之间用下划线分隔。如果违反该规则，编译器会报告警告。

这四个方面，这里我们只看第一个，关于分配种类。
`_A 和 _B 变量各占 4 个字节，_C 占 8 个字节，而 _D 只占 1 个字节。如果进程的地址从零开始（通常不会发生），编译器会将地址 0 分配给 _A，地址 4 分配给 _B，地址 8 分配给 _C，地址 16 分配给 _D。在编译时分配了 17 个字节。`
当程序启动时，进程要求操作系统使用 17 字节的内存。然后，在执行期间，不再执行内存请求。当进程终止时，所有进程内存都会自动释放给操作系统。
静态分配的一个缺点是无法创建递归函数，这些函数是直接或间接调用自身的函数。事实上，如果一个函数的参数和局部变量是静态分配的，那么它们只有一个副本，当函数调用自己时，它不能有另一个参数和局部变量的副本。
静态分配的另一个缺点是所有子程序的所有变量都是在程序开始时分配的。如果程序包含许多变量，但每次特定的执行只使用其中的一小部分，那么许多变量被无用地分配，使程序内存变得很饿。
此外，静态变量修改是不安全的。
因此，在 Rust 中，它们并没有被大量使用。
然而，静态分配被广泛用于另外两种类型的数据：所有可执行的二进制代码（实际上并不是真正的“数据”），以及所有的字符串文字。

### Stack Allocation    堆栈分配

由于静态分配的缺点，Rust 大量使用堆栈分配。每次使用 let 关键字声明变量时，以及每次将参数传递给函数调用时，Rust 都会在名为 stack 的地址空间的一部分中分配一个对象。每个进程都有自己的堆栈。

事实上，每个线程都有一个堆栈，而不仅仅是每个进程都有一个堆栈。如果操作系统支持线程，那么每次启动一个程序，也就是每次创建一个进程，都会在这个进程内部创建并启动一个线程。之后，在同一进程内，可能会创建和启动其他线程。每次创建一个线程，包括进程的主线程，都会要求操作系统分配一部分地址空间，也就是那个线程的栈。在实内存系统中，在程序执行开始时只创建一个堆栈。

每个线程都保存着堆栈末端的地址。通常，具有较高值的一端被认为是堆栈的底部，而具有较低值的一端被认为是堆栈的顶部

让我们考虑下面的代码，类似于前面的代码，但使用堆栈分配而不是静态分配：

``` rust
let _a: u32 = 3;
let _b: i32 = -1_000_000;
let _c: f64 = 5.7e10;
let _d: u8 = 200;
```

这个程序只有一个线程。现在假设，非常不切实际，这个线程只有 100 个字节的堆栈，地址从 500 包括到 600 不包括在内。当这个程序运行时，四个变量从基地址向下分配，即 600。

因此，如图 11-1 所示，`_a 变量将占用地址从 596 到 599 的 4 个字节，_b 变量将占用地址从 592 到 595 的 4 个字节，_c 变量将占用地址从 592 到 595 的 8 个字节地址从 584 到 591，_d 变量将只占用地址为 583 的字节。`


然而，当你需要指明一个对象的地址时，你必须总是指明低位地址。所以，我们说 _a 在地址 596，_b 在地址 592，_c 在地址 584，_d 在地址 583

栈这个词是指如果我们有一堆中国菜，我们不应该在堆栈中间插入一个盘子，也不应该从堆栈中间取出一个盘子。我们只允许在栈顶添加一个盘子，如果它还没有到达天花板，或者从栈顶移除一个盘子，如果栈不是空的。

同理，栈分配的特点是只能在栈顶添加一项，只能从栈顶移除一项。

堆栈分配和释放非常快，因为它们分别由递减或递增最后插入和尚未删除的项目的地址组成，即堆栈顶部的地址。该地址被命名为堆栈指针，它一直保存在处理器寄存器中。当发生上下文切换并且控制权传递给另一个线程时，该线程的堆栈指针被加载到处理器寄存器中。

仅在顶部操作的堆栈限制仅适用于分配和释放，不适用于其他类型的访问。事实上，一旦将一个对象添加到堆栈中，即使添加了其他对象，也可以读取和写入该对象，只要此类写入不会增加或减少该对象的大小。

调用函数时，会为其所有参数和所有局部变量分配足够的堆栈空间。分配是通过将堆栈指针减少所有此类对象的大小之和来执行的。当函数的执行终止时，通过将堆栈指针增加相同的值来释放堆栈空间。因此，在函数返回后，堆栈指针会恢复到函数调用之前的值。

然而，一个函数可以从程序中的多个点调用，在这些点上，堆栈可能有不同大小的内容。因此，任何函数的参数和局部变量都根据调用该函数的位置分配在不同的位置。这是一个例子

```rust
#[allow(unused_variables)]
fn f1(x1: i32) {
    let y1 = 2 + x1;
}
fn f2(x2: i32) {
    f1(x2 + 7);
}
let k = 20;
f1(k + 4);
f2(30);
```

让我们关注这个程序的执行情况。此表显示每次操作后堆栈的前四个位置的内容。

实际上，每当调用一个函数时，都会将更多数据添加到堆栈中，而每当该函数终止时，这些数据就会从堆栈中删除，但在这里我们可以忽略这些额外数据。如上表所示，f1 函数被调用了两次。第一次，它的参数 x1 由一个值为 24 的对象表示，放在堆栈的第二个位置，它的局部变量 y1 由一个值为 26 的对象表示，放在堆栈的第三个位置。第二次调用 f1，它的参数 x1 由一个值为 37 的对象表示，放在堆栈的第三位，其局部变量 y1 由一个值为 39 的对象表示，放在堆栈的第四位。

因此，为函数 f1 生成的机器代码不能使用绝对地址来引用其参数和局部变量。相反，它使用相对于堆栈指针的地址。最初，堆栈指针包含堆栈的基地址。在机器代码中，堆栈分配变量的地址都是相对于堆栈指针的。让我们再看看前面的例子

这张表显示了每次操作后堆栈的前四个位置的内容、堆栈指针的值以及与变量 x1 和 y1 关联的对象的绝对地址，其中 SP 表示“堆栈指针”

程序开始时，栈指针值是栈基地址，栈的内容是未定义的，变量x1和y1还没有定义。
当系统调用主函数时，堆栈指针变为base-4，因为主函数没有参数，只有一个局部变量 k，占用 4 个字节

第一次调用 f1 函数时，堆栈指针变为 base - 12，因为 f1 函数有一个参数 x1 和一个局部变量 y1，每个变量占用 4 个字节。
y1 的创建和销毁不会改变堆栈指针，因为它的适当值已经在函数调用时设置。

当函数 f1 终止时，堆栈指针恢复为函数调用之前的值，即base-4。

当调用函数 f2 时，堆栈指针会增加其参数 x2 的大小，将其设置为 base - 8 的值

当第二次调用 f1 函数时，堆栈指针变为base - 16，因为它减少了与第一次调用相同的数量，即 8 个字节。
随着每个 f1、f2 和 main 函数终止，堆栈指针递增，首先到 base - 8，然后到 base - 4，然后到 base。

如表的最后两列所示，在 f1 函数中，参数 x1 的地址始终是堆栈指针的值减 4；并且局部变量 y1 的地址始终是堆栈指针本身的值。

### Limitations of Stack Allocation   堆栈分配的限制

堆栈分配非常方便高效，但也有一些局限性：
* 堆栈的大小通常非常有限。这种大小取决于操作系统，对于某些应用程序可以进一步减小，但数量级约为几兆字节。
* Rust 允许我们仅在堆栈中分配大小在编译类型时已知的对象，例如原始类型和数组，并且不允许我们在堆栈中分配大小仅在运行时确定的对象，例如向量。
* 不允许显式分配堆栈中的对象，或显式释放堆栈中的对象。任何变量在调用声明它的函数时都会自动分配，即使它是在该函数内部的块中声明的，并且在该函数的执行终止时会被释放。你不能推翻这种行为。

关于第二个限制，我们实际上声明了 Vec< _ > 类型的局部变量，因此相应的对象是在堆栈中分配的，但在底层这些对象也分配了一些堆栈之外的内存。

关于第一个限制，很容易构建超出堆栈容量的示例程序。

注意可能会在下面的虚拟机保存程序中发生更改，这可能会导致您正在运行的整个程序崩溃，但也可能导致机器无法运行中的系统故障。因此，他们最好在所有示例之前运行这些程序，因为它们可能会是你重新启动系统。

下面是一个程序超出堆栈容量，导致所谓的堆栈溢出的例子

```rust
const SIZE: usize = 100_000;
const N_ARRAY: usize = 1_000_000;
fn create_array() -> [u8; SIZE] { [0u8; SIZE] }
fn recursive_func(n: usize) {
    let a = create_array();
    println!("{} {}", N_ARRAY - n + 1, a[0]);
    if n > 1 { recursive_func(n - 1) }
}
recursive_func(N_ARRAY);
```

这个程序可能会崩溃，通常会发出“分段错误”或类似的消息。实际上，它试图在堆栈上分配超过 100 GB 的数据。
假设你的目标不是微控制器，它的堆栈应该大于 100KB；因此它可以分配至少一个 100KB 的数组。但是，它可能无法分配一百万个这样的数组。
让我们检查一下这个程序。
在常量 SIZE 和 N_ARRAY 的声明，以及函数 create_array 和 recursive_func 的声明之后，只有一条语句，即调用 recursive_func 函数，以 N_ARRAY 作为参数。
recursive_func函数首先声明了a变量，并用create_array函数的调用结果对其进行初始化；然后它打印两个数字；然后，如果参数 n 大于 1，它会调用自己，因此它实际上是一个递归函数。
请注意，每次递归调用都会传递一个减一的参数，因此最终参数不会大于一，递归最终会结束。
如果 N_ARRAY 为 3，则参数 n 第一次调用时为 3，第二次调用时为 2，第三次调用时为 1，然后就不会再调用了。因此，在这种情况下，recursive_func 总共会被调用 3 次。
确实，调用次数等于原始调用的参数值，即一百万。
现在，看看函数 create_array。它只返回一个 100,000 字节的数组。然后将这样的数组分配给变量 a，因此推断其类型为 [u8; 100000]。
请记住，变量 a 是在调用 recursive_func 函数时分配的，并且仅在该函数终止时才释放。因此，在每次递归调用时，都会分配 a 的新副本，而无需事先释放现有副本。结果，该程序尝试在堆栈中分配一百万个数组，每个数组十万字节。当然它不能这样做，并且在打印了一些行之后，它会终止，通常会显示一个错误消息，如“Segmentation fault”或“Stack Overflow”
打印的最后一行可能是 83 0 之类的东西。
第一个数字表示已经执行了多少级递归，因此，已经分配了多少个数组。如果打印的数字是 83，则表示在超出可用空间之前，在堆栈中成功分配了超过 830 万字节。
第二个数字是数组的第一项，只是为了防止可能的编译器优化。事实上，如果变量 a 从未被读取，编译器在发出警告后可以完全删除它，因为这样的删除将提高程序的性能而不改变其行为（在崩溃之前）

### Heap Allocation 堆分配

当有更多可用内存时，很遗憾有一个程序因堆栈溢出而崩溃。但是堆分配来拯救：

```rust
const SIZE: usize = 100_000;
const N_ARRAY: usize = 1_000_000;
fn create_array() -> Box<[u8; SIZE]> { Box::new([0u8; SIZE]) }
fn recursive_func(n: usize) {
    let a = create_array();
    println!("{} {}", N_ARRAY - n + 1, a[0]);
    if n > 1 { recursive_func(n - 1) }
}
recursive_func(N_ARRAY);
```

最终，即使这个程序由于堆栈溢出或内存不足而崩溃，但只是在打印了比前一个程序多得多的行之后，这意味着它已经成功分配了更多的内存。
“在这个节目中，相对于之前的节目，只有第三行发生了变化。
现在，create_array 函数不是返回一个数组，而是返回一个 Box<[u8; SIZE]>。
这种类型是 SIZE 字节的盒装数组。
在 Rust 中，您可以将大多数数据类型的对象装箱，而不仅仅是数组。 Rust 标准库包含通用结构类型 Box< T >。 Box< T > 类型的对象是对另一个类型为 T 的对象的引用，该对象位于名为堆的内存部分中，与静态区域和堆栈都不同。
create_array 函数的主体是 Box::new([0u8; SIZE])。这个表达式是对在 Box 范围内声明的新函数的调用。这样的函数接收一个 SIZE 字节数组作为参数，它们都等于 0。 Box::new 函数的行为和目的是在堆中分配一个对象，该对象必须足够大以包含接收到的参数的副本，然后将接收到的参数的值复制到这个新分配的对象中，然后返回此类对象的地址。
因此，a变量占用的堆栈空间就是一个指针的空间。实际的数组分配在堆中。好吧，实际上 Box::new 函数会在堆栈中临时分配该数组，但它会在返回后立即释放它。因此，堆栈可以包含该数组的一个实例，占用十万字节就足够了。


### Heap Management 堆管理

让我们看看堆内存是如何管理的。
当一个程序启动时，它的堆实际上是空的（或者非常小）。
在任何时候，堆的每个字节都可能处于两种可能的状态：保留（又名已使用）或空闲（又名未使用）。
当程序需要在堆中分配一个对象时，首先它会搜索堆中是否包含一些至少与要分配的对象大小一样长的空闲字节序列。如果存在这样的字节序列，则程序会从中保留与对象大小一样长的子序列。相反，如果堆不包含足够长的序列，则会向操作系统发出请求以扩大堆的大小，以便可以分配对象。
当不再需要在堆中分配的对象时，可以显式释放它，将其使用的内存空间返回到空闲状态。
请注意，通常进程堆的大小永远不会缩小。
堆管理的一个严重问题是它可能会变得碎片化。如果在堆中分配了一百万个 f64 对象，则该堆必须至少达到 8MB。如果然后每个具有奇数位置（1、3、5，...）的对象都从该堆中释放，我们会遇到这样一种情况：堆包含 50 万个空闲空间，总共 4MB，交错有 50 万个预留空间。有很多可用空间，但是如果您需要分配大于 8 字节的对象，则没有足够大的可用空间来容纳它。所以，你需要扩大那个堆。
此外，在堆中搜索足够大空间的简单算法可能非常昂贵。有更智能的搜索算法可以提高堆分配的性能，但它们会导致堆释放变得更加昂贵。
因此，无论在时间上还是在空间上，堆栈分配总是比堆分配更有效。只有当您从不解除分配或仅解除分配最后分配的对象时，您才能获得几乎与堆栈分配一样有效的堆分配。当然，应用程序要求通常不允许这种分配/解除分配模式。

### The Behavior of Box 盒子的行为

正如我们所说，对于任何 Box< T > 类型的变量，只要调用声明此类变量的函数，就会在堆栈中分配一个指针。相反，堆分配仅在调用函数 Box::new 时发生。因此，Box< T > 的分配分两步进行：首先将指针分配到堆栈中，然后将引用的对象分配到堆中。
同样，释放也分两步进行。仅当包含变量的函数终止时才会从堆栈中释放 Box 对象的指针，但是当 Box 对象退出其范围时，才会从堆中释放引用的对象，如以下程序所示：
``` rust
fn f(p: &f64) {
    let a = Box::new(*p);
    {
        let b = Box::new([1, 2, 3]);
        print!("{} {:?}", *a, *b);
    }
    let c = Box::new(true);
    print!(" {} {}", a, c);
}
f(&3.4);
// This will print: 3.4 [1, 2, 3] 3.4 true.
```




