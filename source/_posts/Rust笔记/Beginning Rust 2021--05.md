---
 title: Rust 2021 版入门
 date: 2022-01-16
 tag: rust
---
# rust

## Allocating Memory (分配内存)

* The various kinds of memory allocation, their performance characteristics, and their limitations (各种内存分配、它们的性能特征和局限性)
* How to specify in Rust which memory allocation to use for an object (如何在 Rust 中指定用于对象的内存分配)
* The difference between a reference and a Box (reference和 Box之间的区别)

### The Various Kinds of Allocation (各种分配)

要理解 Rust 语言，以及任何其他系统编程语言，如 C 语言，重要的是理解内存分配的各种概念，如静态分配、堆栈分配和堆分配。
本章完全致力于这些问题。特别是，我们将看到四种内存分配：
* In processor registers   在处理器寄存器中
* Static  静态分配
* In the stack  在栈中
* In the heap 在堆中

在 C 和 C++ 语言中，静态分配是全局变量和使用 static 关键字声明的变量的分配；堆栈分配用于所有非静态局部变量，也用于函数参数；而堆分配是通过调用 C 语言标准库的 malloc 函数或 C++ 语言的 new 运算符来使用的。

### Linear Addressing 线性寻址
在任何计算机硬件中，都有一种可读写的内存，也称为 RAM，它由一长串字节组成，可以通过它们的位置访问。内存的第一个字节的位置为零，而最后一个字节的位置等于已安装内存的大小减一。
简而言之，在我们这个时代有两种计算机：
* Those where a single process at a time can run, and where such a process directly uses the physical memory addresses. These are called real-memory systems . （那些一次可以运行一个进程，并且这样的进程直接使用物理内存地址的地方。这些被称为实内存系统。）
* Those with a multiprogramming operating system, which offers a virtual address space to each of the running processes. These are called virtual-memory systems （那些拥有多道程序操作系统的人，它为每个正在运行的进程提供了一个虚拟地址空间。这些被称为虚拟内存系统）

在第一类计算机中，现在仅用作控制器，可能没有操作系统（因此它们也被称为裸机系统），或者可能有一个操作系统驻留在内存的第一部分.在最后一种情况下，应用程序可以使用大于某个值的地址。

在第二种计算机中，访问系统内存的任何部分的能力是为操作系统保留的，它以特权模式（也称为保护模式或内核模式）运行，并且此类软件分配部分内存到各种正在运行的进程。

然而，在多道程序系统中，进程对内存的看法与操作系统对内存的看法不同。考虑一下：一个进程请求操作系统允许使用更多的 200 个内存字节，并且操作系统通过为该进程保留（例如，从机器位置 300 到机器位置 499 的内存部分，包括极端情况）来满足这样的请求。然后操作系统通知进程它已经分配了 200 个字节，但它没有通知它这部分内存的起始地址是 300。实际上，每个进程都有一个不同的地址空间，正确地称为虚拟地址空间，操作系统映射到物理内存，恰当地称为真实内存。

实际上，当一个进程向操作系统请求一些内存时，操作系统只是保留了该进程的一部分地址空间，并没有真正为该进程保留真正的内存。因此，即使对于非常大的内存部分，这种分配也非常快。

只要进程试图访问这样的内存，即使只是将其初始化为零，操作系统就会意识到该进程正在访问尚未映射到真实内存的部分虚拟内存；它立即将访问的虚拟内存部分映射到相应的实内存部分。

因此，进程并不直接在真实内存上运行，而是在操作系统为它们提供的虚拟内存上运行，并且它已映射到真实内存。

事实上，通常单个进程的虚拟内存甚至比计算机的整个真实内存还要大。例如，您可以拥有一台具有 1 GB 物理（实际）内存的计算机，并在该计算机上运行四个进程，每个进程具有 3 GB 的虚拟内存空间。如果所有虚拟内存都映射到实际内存，则需要 12 GB 的内存来处理这种情况。相反，虚拟内存的大部分字节都没有映射到真实内存；只有进程实际使用的字节才会映射到实际内存。只要进程开始使用其地址空间中尚未映射到真实内存的部分，操作系统就会将虚拟内存的这些部分映射到真实内存的相应部分。

因此，每当一个进程为了读取或写入而访问一个地址时，如果该地址属于保留的虚拟内存部分（称为页面）并映射到实际内存的相应部分，则该进程会立即访问该实际内存。相反，如果该页面被保留但当前未映射，则操作系统在允许此类访问之前以一种称为页面错误的机制启动，通过该机制分配一个实际内存页面并将该页面映射到所引用的虚拟内存页面通过访问的地址。但是，如果访问的地址不属于操作系统保留的作为进程地址空间一部分的页面，则会发生寻址错误（通常称为分段错误）。这在用 Rust 或更高级别语言（如 Java、JavaScript 或 Python）编写的程序中非常罕见，因为这些语言中的语句只能访问先前为进程保留的内存。相反，这种错误在汇编和 C 等低级语言中很常见，因为在此类语言中，任何数字都可以转换为内存地址，如果地址计算错误，它可能在内存地址空间之外。程序。通常，解决错误会导致流程立即终止。

当然，如果程序过度使用内存，操作系统可能会花费大量时间来进行此类映射，从而导致进程大幅减慢，甚至因内存不足而终止。

因此，在现代计算机中，无论是单程序计算机还是多程序计算机，每个进程都将其内存视为字节数组。一种情况是真实内存，另一种情况是虚拟内存；无论如何，它是一个连续的地址空间，或者，通常所说的，使用线性寻址。这与使用分段地址空间的旧计算机系统不同，应用程序程序员使用起来更加麻烦

所有这一切都说明了，在虚拟内存系统中，操作系统管理一种内存分配，即从虚拟内存到真实内存的映射。不过，从现在开始，我们将不再谈论这种内存分配，我们将内存分配定义为保留进程看到的一部分内存，并将这部分内存与 Rust 对象相关联的操作。

###  Static Allocation 静态分配
不过，有各种分配政策。
最简单的分配策略是静态分配。根据该策略，编译器确定程序对象需要多少字节，并从地址空间中获取相应的字节序列。所有静态分配的对象都是连续布局的。因此，每个变量的地址是在编译时确定的。这是 Rust 中的一个示例：

``` rust
static _A: u32 = 3;
static _B: i32 = -1_000_000;
static _C: f64 = 5.7e10;
static _D: u8 = 200;
```
`static` 关键字类似于 let 关键字。两者都用于声明变量并可选地对其进行初始化
static 和 let 的区别在于
* static 使用静态分配，而 let 使用堆栈分配，下一节介绍。
* static 需要明确指定变量的类型，使用 let 是可选的。
* 普通代码无法更改静态变量的值，即使它具有 mut 规范。因此，在 Rust 中，出于安全原因，静态变量通常是不可变的。
* 样式指南要求静态变量的名称只能包含大写字母，单词之间用下划线分隔。如果违反该规则，编译器会报告警告。

这四个方面，这里我们只看第一个，关于分配种类。
`_A 和 _B 变量各占 4 个字节，_C 占 8 个字节，而 _D 只占 1 个字节。如果进程的地址从零开始（通常不会发生），编译器会将地址 0 分配给 _A，地址 4 分配给 _B，地址 8 分配给 _C，地址 16 分配给 _D。在编译时分配了 17 个字节。`
当程序启动时，进程要求操作系统使用 17 字节的内存。然后，在执行期间，不再执行内存请求。当进程终止时，所有进程内存都会自动释放给操作系统。
静态分配的一个缺点是无法创建递归函数，这些函数是直接或间接调用自身的函数。事实上，如果一个函数的参数和局部变量是静态分配的，那么它们只有一个副本，当函数调用自己时，它不能有另一个参数和局部变量的副本。
静态分配的另一个缺点是所有子程序的所有变量都是在程序开始时分配的。如果程序包含许多变量，但每次特定的执行只使用其中的一小部分，那么许多变量被无用地分配，使程序内存变得很饿。
此外，静态变量修改是不安全的。
因此，在 Rust 中，它们并没有被大量使用。
然而，静态分配被广泛用于另外两种类型的数据：所有可执行的二进制代码（实际上并不是真正的“数据”），以及所有的字符串文字。

### Stack Allocation    堆栈分配

由于静态分配的缺点，Rust 大量使用堆栈分配。每次使用 let 关键字声明变量时，以及每次将参数传递给函数调用时，Rust 都会在名为 stack 的地址空间的一部分中分配一个对象。每个进程都有自己的堆栈。

事实上，每个线程都有一个堆栈，而不仅仅是每个进程都有一个堆栈。如果操作系统支持线程，那么每次启动一个程序，也就是每次创建一个进程，都会在这个进程内部创建并启动一个线程。之后，在同一进程内，可能会创建和启动其他线程。每次创建一个线程，包括进程的主线程，都会要求操作系统分配一部分地址空间，也就是那个线程的栈。在实内存系统中，在程序执行开始时只创建一个堆栈。

每个线程都保存着堆栈末端的地址。通常，具有较高值的一端被认为是堆栈的底部，而具有较低值的一端被认为是堆栈的顶部

让我们考虑下面的代码，类似于前面的代码，但使用堆栈分配而不是静态分配：

``` rust
let _a: u32 = 3;
let _b: i32 = -1_000_000;
let _c: f64 = 5.7e10;
let _d: u8 = 200;
```

这个程序只有一个线程。现在假设，非常不切实际，这个线程只有 100 个字节的堆栈，地址从 500 包括到 600 不包括在内。当这个程序运行时，四个变量从基地址向下分配，即 600。

因此，如图 11-1 所示，`_a 变量将占用地址从 596 到 599 的 4 个字节，_b 变量将占用地址从 592 到 595 的 4 个字节，_c 变量将占用地址从 592 到 595 的 8 个字节地址从 584 到 591，_d 变量将只占用地址为 583 的字节。`


然而，当你需要指明一个对象的地址时，你必须总是指明低位地址。所以，我们说 _a 在地址 596，_b 在地址 592，_c 在地址 584，_d 在地址 583

栈这个词是指如果我们有一堆中国菜，我们不应该在堆栈中间插入一个盘子，也不应该从堆栈中间取出一个盘子。我们只允许在栈顶添加一个盘子，如果它还没有到达天花板，或者从栈顶移除一个盘子，如果栈不是空的。

同理，栈分配的特点是只能在栈顶添加一项，只能从栈顶移除一项。

堆栈分配和释放非常快，因为它们分别由递减或递增最后插入和尚未删除的项目的地址组成，即堆栈顶部的地址。该地址被命名为堆栈指针，它一直保存在处理器寄存器中。当发生上下文切换并且控制权传递给另一个线程时，该线程的堆栈指针被加载到处理器寄存器中。

仅在顶部操作的堆栈限制仅适用于分配和释放，不适用于其他类型的访问。事实上，一旦将一个对象添加到堆栈中，即使添加了其他对象，也可以读取和写入该对象，只要此类写入不会增加或减少该对象的大小。

调用函数时，会为其所有参数和所有局部变量分配足够的堆栈空间。分配是通过将堆栈指针减少所有此类对象的大小之和来执行的。当函数的执行终止时，通过将堆栈指针增加相同的值来释放堆栈空间。因此，在函数返回后，堆栈指针会恢复到函数调用之前的值。

然而，一个函数可以从程序中的多个点调用，在这些点上，堆栈可能有不同大小的内容。因此，任何函数的参数和局部变量都根据调用该函数的位置分配在不同的位置。这是一个例子

```rust
#[allow(unused_variables)]
fn f1(x1: i32) {
    let y1 = 2 + x1;
}
fn f2(x2: i32) {
    f1(x2 + 7);
}
let k = 20;
f1(k + 4);
f2(30);
```

让我们关注这个程序的执行情况。此表显示每次操作后堆栈的前四个位置的内容。







