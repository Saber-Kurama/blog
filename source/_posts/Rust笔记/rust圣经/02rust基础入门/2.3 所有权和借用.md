
## 所有权

内存释放的3种方式

-   **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
-   **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
-   **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

rust 选择了所有权管理内存

```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

`a` 变量造成了`悬空指针(Dangling Pointer)`, `"xyz"` 只有当整个程序结束后系统才能回收这片内存。


## 栈(Stack)和堆(Heap)



## 借用规则总结

总的来说，借用规则如下：

-   同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
-   引用必须总是有效的


### 变量作用域

```rust

#![allow(unused)]
fn main() {
	{                      // s 在这里无效，它尚未声明
	    let s = "hello";   // 从此处起，s 是有效的
	
	    // 使用 s
	}                      // 此作用域已结束，s不再有效
}

```

### 简单介绍string


### 变量绑定背后的数据交互

#### 转移所有权

```rust
#![allow(unused)]
fn main() {
	let x = 5;
	let y = x;
}
```

将 `5` 绑定到变量 `x`；接着拷贝 `x` 的值赋给 `y`，最终 `x` 和 `y` 都等于 `5`

```rust
#![allow(unused)]
fn main() {
	let s1 = String::from("hello");
	let s2 = s1;
}
```

拷贝的话有两种
1. 深拷贝 性能差
2. 浅拷贝，只拷贝指针数据，速度快 违背 **一个值只允许有一个所有者**

当变量离开作用域后，Rust 会自动调用 `drop` 函数并清理变量的堆内存。不过由于两个 `String` 变量指向了同一位置。这就有了一个问题：当 `s1` 和 `s2` 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 **二次释放（double free）** 的错误

因此，Rust 这样解决问题：**当 `s1` 赋予 `s2` 后，Rust 认为 `s1` 不再有效，因此也无需在 `s1` 离开作用域后 `drop` 任何东西，这就是把所有权从 `s1` 转移给了 `s2`，`s1` 在被赋予 `s2` 后就马上失效了**。

所有权转移

1.  Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2.  一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3.  当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

果你在其他语言中听说过术语 **浅拷贝(shallow copy)** 和 **深拷贝(deep copy)**，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 `s1` 无效了，因此这个操作被称为 **移动(move)**，而不是浅拷贝。上面的例子可以解读为 `s1` 被**移动**到了 `s2` 中。

```rust
fn main() {
    let x: &str = "hello, world";
    let y = x;
    println!("{},{}",x,y);
}
```

##### 克隆(深拷贝)



