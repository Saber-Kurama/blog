
## 所有权

内存释放的3种方式

-   **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
-   **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
-   **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

rust 选择了所有权管理内存

```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

`a` 变量造成了`悬空指针(Dangling Pointer)`, `"xyz"` 只有当整个程序结束后系统才能回收这片内存。


## 栈(Stack)和堆(Heap)



## 借用规则总结

总的来说，借用规则如下：

-   同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
-   引用必须总是有效的


### 变量作用域

```rust

#![allow(unused)]
fn main() {
	{                      // s 在这里无效，它尚未声明
	    let s = "hello";   // 从此处起，s 是有效的
	
	    // 使用 s
	}                      // 此作用域已结束，s不再有效
}

```

### 简单介绍string


### 变量绑定背后的数据交互

#### 转移所有权

```rust
#![allow(unused)]
fn main() {
	let x = 5;
	let y = x;
}
```

将 `5` 绑定到变量 `x`；接着拷贝 `x` 的值赋给 `y`，最终 `x` 和 `y` 都等于 `5`

```rust
#![allow(unused)]
fn main() {
	let s1 = String::from("hello");
	let s2 = s1;
}
```

