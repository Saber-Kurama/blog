
## 所有权

内存释放的3种方式

-   **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
-   **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
-   **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

rust 选择了所有权管理内存

```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

`a` 变量造成了`悬空指针(Dangling Pointer)`, `"xyz"` 只有当整个程序结束后系统才能回收这片内存。


## 栈(Stack)和堆(Heap)



## 借用规则总结

总的来说，借用规则如下：

-   同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
-   引用必须总是有效的


### 变量作用域

```rust

#![allow(unused)]
fn main() {
	{                      // s 在这里无效，它尚未声明
	    let s = "hello";   // 从此处起，s 是有效的
	
	    // 使用 s
	}                      // 此作用域已结束，s不再有效
}

```

### 简单介绍string


### 变量绑定背后的数据交互

#### 转移所有权

```rust
#![allow(unused)]
fn main() {
	let x = 5;
	let y = x;
}
```

将 `5` 绑定到变量 `x`；接着拷贝 `x` 的值赋给 `y`，最终 `x` 和 `y` 都等于 `5`

```rust
#![allow(unused)]
fn main() {
	let s1 = String::from("hello");
	let s2 = s1;
}
```

拷贝的话有两种
1. 深拷贝 性能差
2. 浅拷贝，只拷贝指针数据，速度快 违背 **一个值只允许有一个所有者**

当变量离开作用域后，Rust 会自动调用 `drop` 函数并清理变量的堆内存。不过由于两个 `String` 变量指向了同一位置。这就有了一个问题：当 `s1` 和 `s2` 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 **二次释放（double free）** 的错误

因此，Rust 这样解决问题：**当 `s1` 赋予 `s2` 后，Rust 认为 `s1` 不再有效，因此也无需在 `s1` 离开作用域后 `drop` 任何东西，这就是把所有权从 `s1` 转移给了 `s2`，`s1` 在被赋予 `s2` 后就马上失效了**。

所有权转移

1.  Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2.  一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3.  当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

果你在其他语言中听说过术语 **浅拷贝(shallow copy)** 和 **深拷贝(deep copy)**，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 `s1` 无效了，因此这个操作被称为 **移动(move)**，而不是浅拷贝。上面的例子可以解读为 `s1` 被**移动**到了 `s2` 中。

```rust
fn main() {
    let x: &str = "hello, world";
    let y = x;
    println!("{},{}",x,y);
}
```

##### 克隆(深拷贝)

首先，**Rust 永远也不会自动创建数据的 “深拷贝”**。因此，任何**自动**的复制都不是深拷贝，可以被认为对运行时性能影响较小

##### 拷贝(浅拷贝)

浅拷贝只发生在栈上，因此性能很高

Rust 有一个叫做 `Copy` 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 `Copy` 特征，一个旧的变量在被赋值给其他变量后仍然可用。

那么什么类型是可 `Copy` 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则： **任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**。如下是一些 `Copy` 的类型：
-   所有整数类型，比如 `u32`。
-   布尔类型，`bool`，它的值是 `true` 和 `false`。
-   所有浮点数类型，比如 `f64`。
-   字符类型，`char`。
-   元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是。
-   不可变引用 `&T` ，例如[转移所有权](https://course.rs/basic/ownership/ownership.html#%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83)中的最后一个例子，**但是注意: 可变引用 `&mut T` 是不可以 Copy的**

### 函数传值和返回

将值传递给函数，一样会发生 `移动` 或者 `复制`，就跟 `let` 语句一样，下面的代码展示了所有权、作用域的规则：

所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： **总是把一个值传来传去来使用它**。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust 提供了新功能解决这个问题。

## 引用和借用

Rust 通过 `借用(Borrowing)` 这个概念来达成上述的目的，**获取变量的引用，称之为借用(borrowing)**。

### 引用和解引用

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

```

### 不可变引用

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

```

### 可变引用
