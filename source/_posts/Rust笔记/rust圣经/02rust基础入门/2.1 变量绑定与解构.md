##  变量绑定与解构

###  为何要手动设置变量的可变性
不可变的变量安全，可变灵活。所以手动设置可变性会既灵活又安全
**一切皆为权衡**
另外也可以提升性能

### 变量命名

通常，对于 **type-level** 的构造 Rust 倾向于使用**驼峰命名法**，而对于 **value-level** 的构造使用**蛇形命名法**。详情如下：



### 变量绑定

在其他语言中 
`let a = "hello world"`
我们任务这个是变量赋值，但是在`rust`中我们认为这是**变量绑定**


### 变量可变性

```rust
fn main() {
	let mut x = 5;
	println!("The value of x is: {}", x);
	x = 6;
	println!("The value of x is: {}", x)
}
```

### 使用下划线开头忽略未使用的变量

**你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头**：
``` rust
fn main() {
	let _x = 5;
	let y = 10;
}

```

### 变量解构

`let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：
``` rust
fn main() {
	let (a, mut b): (bool, bool) = (true, false);
	println!("a = {:?}, b = {:?}", a, b);
	b = true;
	assert_eq!(a, b);
}
```

#### 解构赋值

在 [Rust 1.59](https://course.rs/appendix/rust-versions/1.59.html) 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了。

``` rust
struct Struct {
	e: i32
}

fn main() {
	let (a, b, c, d, e);
	(a,)
}
```

### 变量和常量之间的差异

### 变量遮蔽
