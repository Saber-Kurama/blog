##  变量绑定与解构

###  为何要手动设置变量的可变性
不可变的变量安全，可变灵活。所以手动设置可变性会既灵活又安全
**一切皆为权衡**
另外也可以提升性能

### 变量命名

通常，对于 **type-level** 的构造 Rust 倾向于使用**驼峰命名法**，而对于 **value-level** 的构造使用**蛇形命名法**。详情如下：



### 变量绑定

在其他语言中 
`let a = "hello world"`
我们任务这个是变量赋值，但是在`rust`中我们认为这是**变量绑定**


### 变量可变性

```rust
fn main() {
	let mut x = 5;
	println!("The value of x is: {}", x);
	x = 6;
	println!("The value of x is: {}", x)
}
```

### 使用下划线开头忽略未使用的变量

**你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头**：
``` rust
fn main() {
	let _x = 5;
	let y = 10;
}

```

### 变量解构

`let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：
``` rust
fn main() {
	let (a, mut b): (bool, bool) = (true, false);
	println!("a = {:?}, b = {:?}", a, b);
	b = true;
	assert_eq!(a, b);
}
```

#### 解构赋值

在 [Rust 1.59](https://course.rs/appendix/rust-versions/1.59.html) 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了。

``` rust
struct Struct {
	e: i32
}

fn main() {
	let (a, b, c, d, e);
	// 元组
	(a, b) = (1, 2);
	// 
	[c, ..., d, _] = [1, 2, 3, 4, 5];
	// 结构体
	Struct { e, ..} = Strct {e: 5};
	assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]); 
}
```

需要注意的是，使用 `+=` 的赋值语句还不支持解构式赋值。

### 变量和常量之间的差异

变量的值不能更改可能让你想起其他另一个很多语言都有的编程概念：**常量**(_constant_)。与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异：

-   常量不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值。
-   常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。

### 变量遮蔽
