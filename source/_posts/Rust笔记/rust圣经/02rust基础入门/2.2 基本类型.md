## 基本类型

Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：

-   数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
-   字符串：字符串字面量和字符串切片 `&str`
-   布尔类型： `true`和`false`
-   字符类型: 表示单个 Unicode 字符，存储为 4 个字节
-   单元类型: 即 `()` ，其唯一的值也是 `()`

## 类型推导与标注

`rust`是静态类型语言，编译期间是需要知道所有变量的类型，但是不必给每个变量指定类型，因为rust的编辑器可以根据变量的值和上下文中使用方式自动推导出变量的类型，在某些情况下无法推导出变量类型，需要手动给予一个类型标注


## 整数类型

|长度|有符号类型|无符号类型|
|----|----|----|
|8位|`i8`|`u8`|
|16位|`i16`|`u16`|
|32位|`i32`|`u32`|
|64位|`i64`|`u64`|
|128位|`i128`|`u128`|
|size|`isize`|`usize`|

### 整型溢出


## 浮点类型

```rust
fn main() { 
	let x = 2.0; // f64 
	let y: f32 = 3.0; // f32 
}

```

### 浮点数陷阱


## 数字运算

 `+` `-` `*` `/` `%`
``` rust
fn main() {
	// 加法
	let sum = 5 + 10;
}

```

## 位运算

## 序列

Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 `1..5`，生成从 1 到 4 的连续数字，不包含 5 ；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：

``` rust

for i in 1..5 {
	println!("{}", i);
}

```
## 有理数和复数


## 字符类型（char）

所有 `unicode` 都可以作为Rust字符
``` rust
fn main() {
	let c = 'z';
	let z = 'ℤ';
	let g = '国'; 
	let heart_eyed_cat = '😻';
}
```

## 布尔 （bool）

Rust 中的布尔类型有两个可能的值：`true` 和 `false`，布尔值占用内存的大小为 `1` 个字节：
``` rust
fn main() {
	let t = true;
	let f: bool = false; // 类型标注 显示指定
}
```

## 单元类型

单元类型就是 `()` ，对，你没看错，就是 `()` ，唯一的值也是 `()` ，一些读者读到这里可能就不愿意了，你也太敷衍了吧，管这叫类型？

只能说，再不起眼的东西，都有其用途，在目前为止的学习过程中，大家已经看到过很多次 `fn main()` 函数的使用吧？那么这个函数返回什么呢？

没错， `main` 函数就返回这个单元类型 `()`，你不能说 `main` 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：`发散函数( diverge function )`，顾名思义，无法收敛的函数。

例如常见的 `println!()` 的返回值也是单元类型 `()`。

再比如，你可以用 `()` 作为 `map` 的值，表示我们不关注具体的值，只关注 `key`。 这种用法和 Go 语言的 _**struct{}**_ 类似，可以作为一个值用来占位，但是完全**不占用**任何内存。

## 语句和表达式

``` rust
fn add_with_extra(x: i32, y: i32) -> i32 {
	let x = x + 1; // 语句
	let y = y + 5; // 语句
	x + 5 // 表达式
}
```
对于 Rust 语言而言，**这种基于语句（statement）和表达式（expression）的方式是非常重要的，你需要能明确的区分这两个概念**, 但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，**表达式总要返回值**。

### 语句

