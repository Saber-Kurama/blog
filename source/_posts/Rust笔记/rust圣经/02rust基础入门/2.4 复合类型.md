只使用基本类型的局限性：**无法从更高的抽象层次去简化代码**。

## 字符串和切片

## 切片 （slice）

切片并不是 Rust 独有的概念，在 Go 语言中就非常流行，它允许你引用集合中部分连续的元素序列，而不是引用整个集合。

对于字符串而言，切片就是对 `String` 类型中某一部分的引用，它看起来像这样：

``` rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
```
![[Pasted image 20221026204959.png]]

一些语法糖
``` rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
let hell0 = &s[..5];
let world = &s[..11];
let helloworld = &s[..];
```

## 字符串字面量是切片


## 什么是字符串

顾名思义，字符串是由字符组成的连续集合，但是在上一节中我们提到过，**Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)**，这样有助于大幅降低字符串所占用的内存空间。

Rust 在语言级别，只有一种字符串类型： `str`，它通常是以引用类型出现 `&str`，也就是上文提到的字符串切片。虽然语言级别只有上述的 `str` 类型，但是在标准库里，还有多种不同用途的字符串类型，其中使用最广的即是 `String` 类型。

`str` 类型是硬编码进可执行文件，也无法被修改，但是 `String` 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，**当 Rust 用户提到字符串时，往往指的就是 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码**。

除了 `String` 类型的字符串，Rust 的标准库还提供了其他类型的字符串，例如 `OsString`， `OsStr`， `CsString` 和 `CsStr` 等，注意到这些名字都以 `String` 或者 `Str` 结尾了吗？它们分别对应的是具有所有权和被借用的变量。


## String与&str 的转换

在之前的代码中，已经见到好几种从 `&str` 类型生成 `String` 类型的操作：
-   `String::from("hello,world")`
-   `"hello,world".to_string()`

那么如何将 `String` 类型转为 `&str` 类型呢？答案很简单，取引用即可：

``` rust
fn main () {
	let s = String::from("hell0, world!");
	say_hello(&s);
	say_hello(&s[..]);
	say_hello(s.as_str());
}

fn say_hello(s: &str) {
	println!("{}", s);
}
```

## 字符串索引

所以，可以看出来 Rust 提供了不同的字符串展现方式，这样程序可以挑选自己想要的方式去使用，而无需去管字符串从人类语言角度看长什么样。

还有一个原因导致了 Rust 不允许去索引字符串：因为索引操作，我们总是期望它的性能表现是 O(1)，然而对于 `String` 类型来说，无法保证这一点，因为 Rust 可能需要从 0 开始去遍历字符串来定位合法的字符。

## 字符串切片

前文提到过，字符串切片是非常危险的操作，因为切片的索引是通过字节来进行，但是字符串又是 UTF-8 编码，因此你无法保证索引的字节刚好落在字符的边界上，例如：

``` rust
let hello = "中国人";
let s = &hello[..2];
```
大部分中文是3个字节
这里提示的很清楚，我们索引的字节落在了 `中` 字符的内部，这种返回没有任何意义。

因此在通过索引区间来访问字符串时，**需要格外的小心**，一不注意，就会导致你程序的崩溃！

##  操作字符串

由于 `String` 是可变字符串，下面介绍 Rust 字符串的修改，添加，删除等常用方法：

### 追加（push）

在字符串尾部可以使用 `push()` 方法追加字符 `char`，也可以使用 `push_str()` 方法追加字符串字面量。这两个方法都是**在原有的字符串上追加，并不会返回新的字符串**。由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即**字符串变量必须由 `mut` 关键字修饰**。

``` rust
fn main () {
	let mut s = String::from("hello ");
	s.push('r');
	println!("追加字符 push() -> {}", s);

	s.push_str("ust!");
	println!("追加字符串 push_str() -> {}", s);
}
```


## 字符串转义

我们可以通过转义的方式 `\` 输出 ASCII 和 Unicode 字符。

``` rust
// 通过 \ + 字符的十六进制表示，转义输出一个字符 
let byte_escape = "I'm writing \x52\x75\x73\x74!";
// \u 可以输出一个 unicode 字符 
let unicode_codepoint = "\u{211D}";
// 换行了也会保持之前的字符串格式 
let long_string = "String literals can span multiple lines. The linebreak and indentation here ->\ <- can be escaped too!"; 
println!("{}", long_string);
```

不要转义

``` rust
println!("{}", "hello \\x52\\x75\\x73\\x74"); 
let raw_str = r"Escapes don't work here: \x3F \u{211D}"; 
println!("{}", raw_str); 
// 如果字符串包含双引号，可以在开头和结尾加 # 
let quotes = r#"And then I said: "There is no escape!""#; 
println!("{}", quotes); 
// 如果还是有歧义，可以继续增加，没有限制 
let longer_delimiter = r###"A string with "# in it. And even "##!"###; 
println!("{}", longer_delimiter);
```

## 操作 UTF-8 字符串

### 字符
如果你想要以 Unicode 字符的方式遍历字符串，最好的办法是使用 `chars` 方法，例如：

``` rust
for c in "中国人".chars() { 
	println!("{}", c); 
}
```

### 字节

这种方式是返回字符串的底层字节数组表现形式：

### 获取子串



## 字符串深度剖析

那么问题来了，为啥 `String` 可变，而字符串字面值 `str` 却不可以？

就字符串字面值来说，我们在编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件中，这使得字符串字面值快速且高效，这主要得益于字符串字面值的不可变性。不幸的是，我们不能为了获得这种性能，而把每一个在编译时大小未知的文本都放进内存中（你也做不到！），因为有的字符串是在程序运行得过程中动态生成的。

对于 `String` 类型，为了支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，这些都是在程序运行时完成的：

-   首先向操作系统请求内存来存放 `String` 对象
-   在使用完成后，将内存释放，归还给操作系统

其中第一部分由 `String::from` 完成，它创建了一个全新的 `String`。

重点来了，到了第二部分，就是百家齐放的环节，在有**垃圾回收 GC** 的语言中，GC 来负责标记并清除这些不再使用的内存对象，这个过程都是自动完成，无需开发者关心，非常简单好用；但是在无 GC 的语言中，需要开发者手动去释放这些内存对象，就像创建对象需要通过编写代码来完成一样，未能正确释放对象造成的后果简直不可估量。

对于 Rust 而言，安全和性能是写到骨子里的核心特性，如果使用 GC，那么会牺牲性能；如果使用手动管理内存，那么会牺牲安全，这该怎么办？为此，Rust 的开发者想出了一个无比惊艳的办法：变量在离开作用域后，就自动释放其占用的内存：

``` rust
{ 
	let s = String::from("hello"); // 从此处起，s 是有效的 
	// 使用 s 
} 
// 此作用域已结束，
// s 不再有效，内存被释放
```

与其它系统编程语言的 `free` 函数相同，Rust 也提供了一个释放内存的函数： `drop`，但是不同的是，其它语言要手动调用 `free` 来释放每一个变量占用的内存，而 Rust 则在变量离开作用域时，自动调用 `drop` 函数: 上面代码中，Rust 在结尾的 `}` 处自动调用 `drop`。