
🤔： 所有语言都有基本类型

## 数字相关

### 整数类型

像`js`可能只有 `number`。 为了考虑内存占用，所以`rust`的整数数字类就会有`i8`,`i16`,`i32`,`i64`,`i128`和`isize`。对应的无符号`u8`,`u16`,`u32`,`u64`,`u128`和`usize`

同样机制问题，我们可以这样表示 `0x`, `0O`和`0b`

长数字为了方便 我们可以这样 `4_294_967_295_u32`

将字符表示成u8类型 `b'A'`

数字的计算操作，像`js` 可以用`math`。 rust中可以这样 `2_u16.pow(4)` 更符合类型

#### 溢出处理

`js` 都是直接循环，`rust` 是默认开发报错，运行时循环

所以可以针对溢出做出特别的处理

1. `checked` 返回 正常`Some(v)`，溢出会返回 `None`： 
2. `wrapping` 默认行为，循环
3. `Saturating` 返回最大值
4. `Overflowing`  返回 `tuple(result, overflowed)` , `result`是循环值，`overflowed`是否溢出


### 浮点数

`js` 的浮点数都是 `double`. `rust`是 `f32` 和`f64`


注意： `rust` 几乎不隐式执行数字转换

## 布尔类型

这个也和所有语言差不多。 不同的 true 和 false 可用用as 转换成 1 和 0.但是不能讲数字转换成`bool`

## 字符

`Rust` 的字符类型 `char` 表示单个 `Unicode` 字符，为 `32` 位值。



## 元组

元组更像不同类型的数组

在某种程度上，`tuple` 很像 `array`，都表示有序的值序列。有些编程语言中将他们统一在，但是在 `rust` 中，这完全是隔离开的。主要有两大区别：

1. `tuple` 的元素类型可以不同，但是数组所有元素的类型都是相同的；
2. `tuple` 只能用常量作为索引，例如 `t.4`，不能用 `t.i` 或者 `t[i]` 去访问第 `i` 个元素；



## 指针类型

这个应该属于比较复杂

`Rust` 是不同的，该语言旨在帮助将内存分配保持在最低限度，对于值 `((0，0), (1440，900))` 存储为 `4` 个相邻整数。如果将其存储在局部变量中，则有一个 `4` 个整数宽的局部变量。

这会极大提高内存的效率，但因此，当 `Rust` 程序需要值来指向其他值时，它必须显式使用指针类型。好消息是安全 `Rust` 中使用的指针类型受到限制，以消除未定义的行为，因此在 `Rust` 中比在 `C++` 中正确使用指针容易得多。

### 引用

把引用看作是 `Rust` 的基本指针类型，是最容易入门的。在运行时，对 `i32` 的引用是保存 `i32` 地址的单个机器字，该地址可能在堆栈上或堆栈中。表达式 `&x` 产生对 `x` 的引用；在 `Rust` 术语中，我们说它借用了对 `x` 的引用。给定引用 `r`，表达式 `*r` 指的是 `r` 指向的值。这些非常像 `C` 和 `C++` 中的 `&` 和 `*` 运算符。

`Rust` 有两种形式的引用：

- `&T`：可共享的，但不可变的引用，可以一次对给定值进行许多共享引用，但它们是只读的，不能修改它们指向的值，就像 `C` 中的 `const T*` 一样；
    
- `&mut T`：可变的，但不可共享引用，可以读取和修改它指向的值，就像 `C` 中的 `T*` 一样。但只要该类型引用存在，就不会存在任何其他类型的该值引用；
    

`Rust` 的共享引用和可变引用其实就是多读单写，它可以由任何数量的 `reader` 共享，但 `writer` 始终只有一个，`Rust` 在编译时就会执行这种检查，也是 `Rust` 安全的核心。

### box

智能指针

### 原始指针

## 数组，vector 和切片

### 数组

固定类型，长度不可变 `[V; N]`

### vector

`Vec<T>` 是分配给堆上的 `T` 类型的大小可调整的数组

创建方式
1. 最简单的使用 `vec!` 宏，它给了一个特像创建数组字面量的方式；
2. `vec![0; 100]`，类似数组的初始化语法，将 `vector` 中的值都初始化相同的元素，`vec!` 宏类似于调用 `Vec::new`；
3. 从迭代器创建；类似 `(0..5).collect();`

内存结构方案

### 切片

`slice` 的类型是 `[T]`，没有指定长度，是一个数组或者 `vector` 的一部分。由于 `slice` 可以是任何长度，`slice` 不能直接存储在变量中或作为函数参数传递，参数或者变量的大小必须在编译时就能确定占用空间的大小，必须实现 [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html)，因此 `slice` 总是通过引用传递。



## 字符串类型

这个一个复杂的类型

### 字符串字面量

### String

### &str



## 类型别名

`type` 关键字可以像 `C++` 中的 `typedef` 一样用于为现有类型声明新名称

