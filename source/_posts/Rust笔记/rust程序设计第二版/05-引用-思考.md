
🤔： rust 的两类指针

注意这里用的是指针

在 `Rust` 中，指针按是否有所有权属性可以分为两类，例如 `Box<T>`，`String`，或者 `Vec` 具有所有权属性的指针（`owning pointers`），可以说它们拥有指向的内存，当它们被删除时，指向的内存也会被被释放掉。但是，也有一种非所有权指针，叫做引用 `(references)`，它们的存在不会影响指向值的生命周期，在 `Rust` 中创建引用的行为称之为对值的借用。

🤔： rust 的解引用

如果每次访问引用指向的值，都需要 `*` 操作符，在访问结构体字段的时候，不难想象，体验有点糟糕。所在，在 `Rust` 中，可以通过 **`.`** 操作符隐式地解引用它的左操作数。

除此之外，**`.`** 操作符还可以隐式地从它的左操作数创建引用，因此下面两个操作使等价的：


**`.`** 操作符 可以隐式解引用也可以隐式的创建引用。 这个增加开发体验

🤔： 引用更新

一开始 `r` 借用了 `x`，后面又借用了 `y`


🤔： 引用的引用

难度借用不是 引用的引用 的实现或者产生吗？
不是因为第一种指针并不是引用， 应该说是指针的指针

🤔：引用比较

同 **`.`** 操作符一样，比较运算符也有这样的效果，能连续解引用直到找到最终的值

如果我们确实想知道两个引用它们指向的内存地址是否相同，我们可以使用 `std::ptr::eq`

但是，无论如何，比较操作符左右两侧的操作数必须要有相同的类型


🤔： 从任何表达式借用引用

嗯，这个必须的

🤔：胖指针

胖指针，即 `fat pointers`，指哪些不仅仅是包含了地址的指针，就像 `&[T]`，引用自 `slice` 的指针除了包含首元素的地址之外，还包括 `slice` 的数量；

另一种胖指针是 `trait` 类型，详细请看 [`Trait` 对象](https://blog.fudenglong.site/2022/04/26/%E3%80%90Rust%E3%80%91Trait%E5%92%8C%E6%B3%9B%E5%9E%8B/#trait-%E5%AF%B9%E8%B1%A1)。

🤔：引用安全性，为啥会强调安全性，会不安全？

我想不安全就是，所有权的人不在了，但是借用的人还在。 也就是悬垂引用

为了解决这个问题就引出了一个术语 `生命周期`

`Rust` 规定 **约束 1：值的生命周期必须大于它的引用的生命周期**。

**约束 2：如果我们将引用存储在一个变量中，那么这个引用必须要覆盖这个变量的整个生命周期，从它的初始化到最后一次使用为止**。

