
🤔： 为啥有所有权，解决什么问题，会带来什么问题

先说所有权就先说目前针对内存的处理方案

* 一种以 `java`, `javascript` 等语言的`GC`自动回收
* 另外一种 `c` 和 `c++`, 内存的申请和回收交个了开发者

自动`GC` 效率会降低， 自动释放内存会增加开发者难度

所以 `Rust` 提出了另外一种所有权

简单来说，每一个值都有一个决定其生死的所有者，当所有者被释放的时候，它所拥有的值所占的内存也会被释放

但是这样会带来开发的不友好，所以

* 值的所有者是可以转移
* 简单类型可以copy
* 可以借用值的引用，引用不改变值的所有值
* 可以在某些规则下使用 计数类型， 让值拥有多个所有者


## 所有权转移

简单来说讲值的所有值转移给别人

### 所有权转移和索引

当我们是集合的索引值的

``` rust
let mut c_a = Vec::new();
for i in 101..106 {
	c_a.push(i.to_string());
}
// 这里要发生了所有权转移，但是如果真的转移了 c_a 就必须知道哪些元素是活着，哪些未初始化
// 所以这里会编译报错
let third = c_a[0];
```

类似 `Vec` 的集合类方法也提供了用于消费它们中的元素的方法，当我们直接将 `vector` 传递给 `for` 语句时，实际上我们已经将 `v` 的所有权转移了，`v` 处于未初始化状态，下面这段代码也是不能编译的。

## Copy 类型的所有权转移

复制 `copy` 


## 引用借用



## `Rc` 和 `Arc`：共享所有权



🤔: 解决什么问题，会带来什么问题

解决了内存回收问题，带来`所有权转移`问题。 `copy` 解决简单类型，复杂类型 需要要用借用。某些情况需要使用`共享所有权`