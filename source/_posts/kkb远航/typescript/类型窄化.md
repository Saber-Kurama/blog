---
title: ts 类型窄化
date: 2022-01-14
tag: typescript
---

# TS 类型窄化

## `typeof`类型守卫

typeof 返回值
-   `"string"`
-   `"number"`
-   `"bigint"`
-   `"boolean"`
-   `"symbol"`
-   `"undefined"`
-   `"object"`
-   `"function"`

*类型窄化根据类型守卫在字句块重新定义了更具体的类型*

```ts
function padLeft(padding: number | string, input: string) {

if (typeof padding === "number") {

return " ".repeat(padding) + input;

}
return padding + input;

}
```

## 真值类型窄化
下面都是都是false的情况
-   `0`
-   `NaN`
-   `""` （空字符串）
-   `0n`（`bigint`零版本）
-   `null`
-   `undefined`

```ts
function printAll(strs: string | string[] | null) {

if (strs && typeof strs === "object") {

	for (const s of strs) {
	
	console.log(s);
	
	}

} else if (typeof strs === "string") {

	console.log(strs);

}

}
```

请记住，尽管对原语进行真实性检查通常容易出错。

```ts
function printAll(strs: string | string[] | null) {

// !!!!!!!!!!!!!!!!

// DON'T DO THIS!

// KEEP READING

// !!!!!!!!!!!!!!!!

if (strs) {

	if (typeof strs === "object") {
	
	for (const s of strs) {
	
	console.log(s);
	
	}
	
	} else if (typeof strs === "string") {
	
	console.log(strs);
	
	}

}

}
```
我们将整个函数体包装在一个真值检查中，但这有一个微妙的缺点：我们可能不再正确处理空字符串大小写。*注意隐示转换带来的问题*

*真值窄化帮我们更好的处理 null/undefined/0等情况*

## 相等性窄化
使用`===`， `!==`, `==`和`!=`来进行窄化

```ts
function example(x: string | number, y: string | boolean) {
	if (x === y) {
		// We can now call any 'string' method on 'x' or 'y'.
		x.toUpperCase();
		y.toLowerCase();
	} else {
		console.log(x);
		console.log(y);
	}
}
```

注意 `==`

```ts
interface Container {

value: number | null | undefined;

}

function multiplyValue(container: Container, factor: number) {

	// Remove both 'null' and 'undefined' from the type.
	if (container.value != null) {
		console.log(container.value);
		
		// Now we can safely multiply 'container.value'.
	
		container.value *= factor;
	
	}

}
```