# 类型的重要性
类型是什么？
1. 思考的方式
2. 错误检查的利器

## 类型的思考的方式

面向对象
  类对象
面向函数
 接口

 rust 和 Haskell 函数式都是强类型语言

 ### 类型思考是怎么思考的
 1. 分类思维 
 2. 映射（转换）
 3. 演化 （变换）

通过类型的演进不断让系统进化

 ## 错误的检查利器

 帮助减少程序错误

 其实关于强类型的优点，rust 中有很好的说明
 1.  强类型可以在编译阶段提供更多的错误，而不是在运行时才发现
 2.  强类型可以在编译的过程中开启更多的优化


通过类型的演进不断
 ## 错误的检查利器

 # TS 介绍

 * typesript 是javascript的超集
 * 支持 clinet 和 server
 * ts是多范式
 * ts 同时支持 Duck Typing . Gradual Typing 和 Strick Typing

ts 更重要的类型的思考

 目标
 1. 理解ts原理（编译时，运行时）
 2. 常见用法
 3. 配置ts
 4. 熟悉ts生态

 可以教会别人ts

 # 搞定环境的配置

 * ts-node
 * tsconfig.json
 * tsc
 * 

 # TS 日常类型

 ## 基础类型
 string , number , boolean , null , undefined

 ##  数组类型
 
` Array<T>`

思考： 要求数组统一的优势是什么

rust 中的数组，vector。和 元组

## any / unknown / noImplictAny

``` js
any 不做检查
implict 隐示
explict 显示

noImplictAny 是配置项

unknown  一个类型是unknown类型，那么 可以给它赋值任意类型，但是不能将unkown赋值为其他类型

let a: unkown = 1;
a = 'saber';  // 是正确的
let b: number = 1;
b = a; // 报错

通常用 any 的地方，可以用unknown
```

## 类型标注
```ts
let str: string = 'saber'
```

 ## 函数
 
```ts
// Parameter type annotation

function greet(name: string): string {

console.log("Hello, " + name.toUpperCase() + "!!");
return 26;

}
```

 ## 匿名函数
``` ts
const names = ["Alice", "Bob", "Eve"];

// Contextual typing for function

names.forEach(function (s) {

console.log(s.toUpperCase());

});

// Contextual typing also applies to arrow functions
names.forEach((s) => {

console.log(s.toUpperCase());

});
```
 Contextual typing(根据上下文猜测匿名函数的类型)

 ### 函数可选参数

 ``` ts
 function greet(name: string, name2?: string): string {
	console.log("Hello, " + name.toUpperCase() + "!!");
	return 26;
}
 ```

 ## 对象类型

 ``` ts
function printCoord(pt: { x: number; y: number }) {

console.log("The coordinate's x value is " + pt.x);

console.log("The coordinate's y value is " + pt.y);

}

printCoord({ x: 3, y: 7 });
 ```
 
 可选属性
 ``` ts
 function printName(obj: { first: string; last?: string }) {
// ...
}
 ```

 ### `?.`表达式
 