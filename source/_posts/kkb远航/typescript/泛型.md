---
title: ts 泛型
date: 2022-01-13
tag: typescript
---

# 泛型

抽象的思考方式

1. 继承
2. 接口
3. 泛型

个人认为泛型是多态

##  hello 泛型
``` ts
function identity<Type>(arg: Type): Type {

return arg;

}
```

使用
``` ts
let output = identity<string>("myString");
let output = identity("myString"); // 可以类型推断
```

## 使用泛型类型变量
```ts
function identity<Type>(arg: Type): Type {

	return arg;

}
```

``` typescript
// 和上一个例子相比 arg.length 是不会报错，没有将泛型用于 args
function loggingIdentity<Type>(arg: Type[]): Type[] {

console.log(arg.length);

return arg;

}

```

## 泛型类型
我们将探讨函数本身的类型以及如何创建通用接口。

```ts
function identity<Type>(arg: Type): Type {
	return arg;
}
let myIdentity: <Type>(arg: Type) => Type = identity;
let myIdentity: <Input>(arg: Input) => Input = identity; // 也可以使用不同名称
```
我们还可以将泛型类型写为对象字面量类型的调用签名
```typescript
function identity<Type>(arg: Type): Type {
	return arg;
}
let myIdentity: { <Type>(arg: Type): Type } = identity;
```
这导致我们编写我们的第一个通用（泛型）接口。让我们从前面的示例中获取对象字面量并将其移动到接口：
```typescript
interface GenericIdentityFn {
	<Type>(arg: Type): Type;
}

function identity<Type>(arg: Type): Type {
	return arg;
}

let myIdentity: GenericIdentityFn = identity;

```
在类似的示例中，我们可能希望将泛型参数移动为整个接口的参数。这让我们可以看到我们泛型的类型（例如`Dictionary<string>`，而不仅仅是`Dictionary`）。这使得类型参数对接口的所有其他成员可见
```typescript
interface GenericIdentityFn<Type> {
 (arg: Type): Type;
}

function identity<Type>(arg: Type): Type {

return arg;

}

let myIdentity: GenericIdentityFn<number> = identity;
```
