# 微前端架构和挑战

微前端代表一个业务领域，它是自治的、可独立交付的并由单个团队拥有。本描述中的关键要点（稍后将讨论）与微前端背后的原则密切相关：

* 业务领域表示
* 自治代码库
* 独立部署
* 单一团队所有权

微前端提供了许多机会。选择合适的取决于项目要求、组织结构和开发人员的经验。在这些架构中，我们面临一些特定的成功挑战，这些挑战取决于我们希望如何在微前端之间进行通信，我们希望如何将用户从一个视图路由到另一个视图，以及最重要的是，我们如何确定微前端的大小。一个微前端。

在本章中，我们将介绍在启动具有微前端架构的项目时要做出的关键决策。然后，我们将讨论一些在生产中使用微前端的公司及其方法。

## 微前端决策框架

构建微前端应用程序有不同的方法。要为我们的项目选择最佳方法，我们需要了解我们将在其中运行的环境。一些架构决策需要预先做出，因为它们将指导未来的决策，例如
 
如何定义微前端，如何编排不同的视图，如何为用户构建最终视图，以及微前端如何通信和共享数据。这些类型的决策称为微前端决策框架。它由四个关键领域组成：

* 定义架构中的微前端是什么  Defining what a micro-frontend is in your architecture
* 组成微前端  Composing micro-frontends
* 路由微前端  Routing micro-frontends
* 微前端之间的通信 Communicating between micro-frontends

### Define Micro-Frontends 定义微前端

让我们从第一个关键决定开始，这将对其他决定产生重大影响。我们需要从技术角度确定我们如何考虑微前端。我们可以决定在同一个视图中有多个微前端，或者每个视图只有一个微前端（图 3-1）。


通过水平拆分，多个微前端将在同一个视图上。多个团队将负责部分视图，并且需要协调他们的工作。考虑到我们甚至可以在不同的视图中重用一些微前端，这种方法提供了更大的灵活性，尽管它还需要更多的纪律和治理才能在同一个项目中不使用数百个微前端

在垂直拆分场景中，每个团队负责一个业务领域，例如身份验证或目录体验。在这种情况下，领域驱动设计 (DDD) 就派上用场了。我们很少将 DDD 原则应用于前端架构，但在这种情况下，我们有充分的理由去探索它。

DDD 是一种软件开发方法，它的开发中心是对域模型进行编程，该域模型对域的过程和规则有丰富的理解。为前端应用 DDD 与我们在后端可以做的略有不同。某些概念绝对不适用，尽管还有其他概念对于设计成功的微前端架构至关重要。例如，Netflix 的核心领域是视频流；该核心域中的子域是目录、注册功能和视频播放器。

共有三种子域类型：

Core subdomains 核心子域

这些是应用程序应该存在的主要原因。在我们的组织中，核心子域应被视为优质公民，因为它们提供的价值高于一切。视频目录将是 Netflix 的核心子域。

Supporting subdomains 支持子域

这些子域与核心域相关，但不是关键区别。它们可以支持核心子域，但对于为用户提供真正的价值并不是必不可少的。一个例子是 Netflix 视频的投票系统。

Generic subdomains 通用子域

这些子域用于完成平台。公司通常决定为他们使用现成的软件，因为
他们与他们的领域没有严格的关系。例如，对于 Netflix，支付管理与核心子域（目录）无关，但它是平台的关键部分，因为它可以访问经过身份验证的部分。

让我们用这些类别来分解 Netflix（见表 3-1）。


|  Subdomain type 子域类型      |  Example 例子 |
| ----------- | ----------- |
|  Core subdomain      |  Catalog 目录       |
|  Supportive subdomain   | Voting system 投票系统|  
|  Generic subdomain   |  Sign-in or sign-up   |


### Domain-Driven Design with Micro-Frontends 具有微前端的领域驱动设计

DDD 中的另一个重要术语是有界上下文：隐藏实现细节的逻辑边界，公开 API 合约以使用其中存在的模型中的数据。

通常，有界上下文将由域和子域定义的业务区域转换为我们定义模型、代码结构以及潜在的团队的逻辑区域。限界上下文通过在它们之间创建契约来定义不同上下文相互通信的方式，通常由 API 表示。这允许团队同时在不同的子域上工作，同时尊重预先定义的合同。

通常在一个新项目中，子域会重叠有界上下文，因为我们可以自由地以最佳方式设计我们的系统。因此，我们可以将特定的子域分配给团队，以交付定义合同的特定业务价值。然而，在遗留软件中，有界上下文可以容纳多个子域，因为这些系统的设计通常没有考虑到 DDD。

微前端生态系统提供了许多技术方法。一些实现是使用 iframe 完成的，而另一些是使用组件库或 Web 组件完成的。我们常常把时间花在确定技术解决方案上，而没有考虑到业务方面。

想想这个场景：三个团队，分布在三个不同的位置，在同一个代码库上工作。这些团队可能会在微前端使用 iframe 或 Web 组件进行横向拆分。

一段时间后，他们意识到同一视图中的微前端需要以某种方式进行通信。然后，其中一个团队将负责聚合视图内的不同部分。团队将花费更多时间在同一个视图中聚合不同的微前端并进行调试，以确保一切正常。

显然，这是过于简单化了。考虑到不同的时区、团队之间的交叉依赖、知识共享或分布式团队结构，情况可能会更糟。所有这些挑战很容易升级为士气低落和交付延误之外的挫败感。因此，我们需要确保我们所走的道路不会让我们的团队失望。

然而，从业务的角度来处理项目，您可以创建一个独立的微前端，而无需跨多个子域进行通信。让我们重新想象一下我们的场景。我们不是使用组件和 iframe，而是使用单页应用程序 (SPA) 和单页。这种方法允许一个完整的团队设计构成视图所需的所有 API，并创建根据流量扩展服务所需的基础设施。微架构、微服务和微前端的组合提供了独立交付，而不会危及整个系统以在生产中发布。

有界上下文有助于设计我们的系统，但我们需要很好地了解业务如何运作，以确定项目内部的正确边界。作为架构师或技术主管，我们的职责是与产品团队或客户投入足够的时间，以便我们能够识别不同的领域和子领域，与他们合作。

在定义了所有有界上下文之后，我们将拥有一个系统地图，代表我们系统所组成的不同区域。在图 3-2 中，我们可以看到有界上下文的表示。在此示例中，有界上下文包含目录微前端，这些微前端通过唯一的入口点（前端的后端）使用来自微服务架构的 API。我们将在第 8 章研究更多关于 API 集成的内容。

在 DDD 中，前端没有被考虑在内，但是当我们使用垂直拆分的微前端时，我们可以很容易地将前端和后端映射到同一个有界上下文中。

我经常看到公司根据康威定律设计系统，该定律指出，“设计系统的组织被限制生产的设计是这些组织的通信结构的副本。”1 这些公司需要他们的团队结构而不是灵活足以适应组织的最佳解决方案，以减少摩擦并更快地朝着最终目标迈进：拥有让客户满意的优质产品！逆康威策略建议发展您的团队和组织结构以推广您想要的架构。

### How to Define a Bounded Context   如何定义有界上下文

过早的优化总是指日可待，这可能导致我们的子域分解，我们在其中分割有界上下文以适应未来的集成。相反，我们需要等到我们有足够的信息来做出明智的决定。

因为我们的业务会随着时间的推移而发展，所以我们还需要审查与有界上下文相关的决策。有时我们从更大的有界上下文开始。随着时间的推移，业务不断发展，最终有界上下文变得难以管理或过于复杂。所以我们决定拆分它。决定拆分有界上下文可能会导致大量代码重构，但也可能大大简化代码库，从而加速未来的新功能和开发。

为避免过早分解，我们将在最后一刻做出决定。通过这种方式，我们可以获得更多信息并清楚地了解我们需要遵循的方向。在定义子域时，我们必须提前与组织内的产品团队或领域专家接触。它们可以为您提供系统运行位置的上下文。始终从数据和指标开始。例如，我们可以轻松了解用户如何与我们的应用程序交互，以及用户通过身份验证和未通过身份验证时的用户旅程。数据在识别子域时提供了强大的清晰度，并且可以帮助创建初始基线，从中我们可以看到我们是否正在改进系统。

如果我们的系统内部没有太多可观察性，让我们花时间来创建它。这样做将在我们开始识别我们的微前端时获得回报。如果没有仪表板和指标，我们就无法了解用户在应用程序中的操作方式。假设我们在登录页面上看到大量流量，其中 70% 的用户进入了身份验证过程（登录、注册、支付等）。从这里开始，只有 40% 的流量订阅服务或使用他们的凭据
访问服务。这些都是关于我们用户在我们平台上的行为的良好迹象。在 DDD 之后，我们将从应用程序的域模型开始，识别子域及其相关的有界上下文，并使用行为数据来指导我们如何对前端应用程序进行切片。

允许用户只下载与登陆页面相关的代码将给他们更快的体验，因为他们不必立即下载整个应用程序，而不会前进到认证区域的 40% 的用户只会下载足够的代码以了解我们的服务。显然，连接速度较慢的移动设备从这种方法中受益的原因有很多：下载的数据更少，使用的内存更少，解析和执行的 JavaScript 更少，从而导致页面的首次交互更快。

请务必记住，并非所有用户会话都包含我们平台公开的所有 URL。因此，预先进行一些研究将有助于我们提供更好的用户体验。通常，选择水平而不是垂直的决定取决于我们必须构建的项目类型。事实上，水平拆分更好地服务于目录或电子商务等静态页面，而不是需要垂直拆分的更具交互性的项目。

另一件需要考虑的事情是我们团队的技能组合。通常，垂直拆分更适合更传统的客户端开发体验，而水平拆分则需要开发人员的体验投资，以便为团队创建可靠且快速的反馈循环。

###  Micro-Frontends Composition 微前端组合

编写微前端应用程序有不同的方法（见图 3-3）

在图3-3中的图表中，我们可以看到组成微前端架构的三种不同方式：

*  Client-side composition 客户端组成
*  Edge-side composition 边域组成
*  Server-side composition 服务器端组成

从图表的左侧开始，我们有一个客户端组合，其中应用程序外壳直接从内容交付网络 (CDN) 加载多个微前端，或者如果微前端尚未缓存在源端，则从源加载CDN 级别。在图的中间，我们在 CDN 级别构建最终视图，从源端检索我们的微前端并将最终结果交付给客户端。该图的右侧显示了原始级别的微前端组合，其中我们的微前端在视图中组合，在 CDN 级别缓存，最后提供给客户端。

现在让我们观察我们如何在技术上实现每个架构。

####  Client-side composition 客户端组合

在客户端组合的情况下，应用程序外壳在自身内部加载微前端，微前端应该有一个 JavaScript 或 HTML 文件作为入口点，以便应用程序外壳可以动态地将文档对象模型 (DOM) 节点附加到HTML 文件的情况或使用 JavaScript 文件初始化 JavaScript 应用程序。

我们还可以使用 iframe 的组合来加载不同的微前端，或者我们可以通过一种称为客户端包含的技术在客户端使用转入机制。客户端包括延迟加载组件，用复杂的组件替换空的占位符标签。例如，一个名为 h-include 的库使用占位符标记，该标记将创建一个对 URL 的 Ajax 请求，并将元素的内部 HTML 替换为请求的响应。

这种方法为我们提供了许多选择，但使用客户端包含与使用 iframe 的效果不同。在接下来的章节中，我们将详细探讨这一部分。

> 
根据维基百科，在计算机科学中，嵌入是
通过超文本引用将电子文档的部分或全部包含到一个或多个其他文档中。嵌入通常在显示参考文档时执行，通常对最终用户是自动且透明的。嵌入的结果是一个单一的集成文档，由从不同来源动态组装的部分组成，可能存储在不同位置的不同计算机上。
嵌入的一个例子是在 HTML 中放置图像。服务器要求客户端在特定位置加载资源并将其插入 DOM 的特定部分。


####  Edge-side composition

通过边缘合成，我们在 CDN 级别组装视图。许多 CDN 提供商为我们提供了使用基于 XML 的标记语言的选项，称为 Edge Side Includes (ESI)。 ESI 不是一种新语言；它是由 Akamai 和 Oracle 等公司在 2001 年提出的。ESI 允许扩展 Web 基础架构，以便利用 CDN 网络提供的全球大量存在点，而数量有限大多数软件通常托管的数据中心容量。 ESI 的一个缺点是每个 CDN 提供商的实现方式不同。因此，多 CDN 策略，以及将我们的代码从一个提供商移植到另一个提供商，可能会导致大量重构和潜在的新逻辑实现。

####  Server-side composition

我们拥有的最后一种可能性是服务器端组合，它可能发生在运行时或编译时。在这种情况下，源服务器通过检索所有不同的微前端并组装最终页面来组成视图。如果页面是高度可缓存的，那么 CDN 将使用较长的生存时间策略为其提供服务。但是，如果页面是针对每个用户进行个性化的，那么当有来自不同客户端的许多请求时，需要认真考虑最终解决方案的可扩展性。当我们决定使用服务器端组合时，我们必须深入分析我们的应用程序中的用例。如果我们决定使用运行时组合，我们必须为我们的服务器制定明确的可扩展性策略，以避免用户停机。
从这些可能性中，我们必须选择最适合我们的项目和团队结构的技术。正如我们稍后将在此旅程中了解到的那样，我们还有机会部署一个同时利用客户端和边缘端组合的架构——只要我们了解如何构建我们的项目就可以了。

###  Routing Micro-Frontends 路由微前端
我们的下一个重要选择是如何路由应用程序视图。这个决定与我们打算用于项目的微前端组合机制密切相关。我们可以决定在源端、边缘或客户端路由页面请求，如图 3-4 所示。

当我们决定在源头（图 3-4 右侧的服务器端组合）组合微前端时，我们被迫在源头路由请求，因为整个应用程序逻辑都存在于应用程序服务器中。但是，我们需要考虑扩展基础设施可能并非易事，尤其是当我们必须管理每秒请求数 (RPS) 的突发流量时。我们的服务器需要能够跟上所有请求并快速横向扩展。然后，每个应用程序服务器都必须能够检索微前端以提供要服务的组合页面。

我们可以在 CDN 的帮助下缓解这个问题。主要缺点是，当我们拥有动态或个性化数据时，我们将无法广泛依赖为我们的页面提供服务的 CDN，因为这些数据会过时或没有个性化。

当我们决定在我们的架构中使用边缘组合时，路由是基于页面 URL 的，CDN 通过在边缘级别通过嵌入来组装微前端来提供请求的页面。在这种情况下，我们将没有太多空间来创建智能路由——当我们选择这种架构时要记住这一点。

最后一个选项是使用客户端路由。在这种情况下，我们将根据用户状态加载我们的微前端，例如当用户已经通过身份验证时加载应用程序的已验证区域，或者如果用户第一次访问我们的应用程序，则仅加载登录页面。

如果我们使用将微前端加载为 SPA 的应用程序外壳，则应用程序外壳负责拥有路由逻辑，这意味着应用程序外壳首先检索路由配置，然后决定加载哪个微前端。当我们有复杂的路由时，这是一种完美的方法，例如当我们的微前端基于身份验证、地理定位或任何其他复杂逻辑时。当我们使用多页网站时，可能会通过客户端嵌入加载微前端。几乎没有适用于这种架构的路由逻辑，因为客户端完全依赖于用户在浏览器中键入的 URL 或在另一个页面中选择的超链接，类似于我们使用 ESI 方法时的情况。

在任何一种情况下，我们都不会有任何可扩展性问题。当您的团队拥有更强的前端技能时，强烈建议使用客户端路由，这样在后端配置上进行客户端路由就变得很自然。

这些路由方法也不是相互排斥的。正如我们将在本书后面看到的那样，我们可以将使用 CDN 和源或客户端和 CDN 的这些方法结合在一起。重要的是确定我们希望如何路由我们的应用程序。这一基本决定将影响我们如何开发我们的微前端应用程序。

###  Micro-Frontends Communication 微前端通信

在理想的世界中，微前端不需要相互通信，因为它们都是自给自足的。实际上，这并不总是可能的，因为我们必须通知其他微前端用户交互，尤其是当我们在同一页面上使用多个微前端时。

当我们在同一个页面上有多个微前端时，为我们的用户管理一致、连贯的用户界面的复杂性可能不是微不足道的。当我们希望在不同团队拥有的微前端之间进行通信时也是如此。请记住，每个微前端都应该不知道同一页面上的其他微前端；否则，我们就违反了独立部署的原则。

在这种情况下，我们有几个选项可以通知其他微前端发生了事件。我们可以在每个微前端中注入一个事件总线，一种允许解耦的组件通过总线发送的事件相互通信的机制，并将事件通知给每个微前端。如果视图中的一些微前端对事件感兴趣，可以监听并做出反应，如图 3-5 所示。

要注入事件总线，我们需要微前端容器来实例化事件总线并将其注入页面的所有微前端。

另一种解决方案是使用custom events。这些是普通事件，但具有自定义主体，它允许我们定义标识事件的字符串和为事件自定义的可选对象。这是一个例子：

``` js
 
new CustomEvent('myCustomEvent', { detail:{someObj: "customData" }})
```

自定义事件应该通过所有微前端都可用的对象来调度，例如窗口对象，它是浏览器中窗口的表示。如果您决定使用
iframes，使用事件总线可以让您避免从 iframe 内部使用哪个窗口对象等挑战，因为每个 iframe 都有自己的窗口对象。无论我们的微前端是水平拆分还是垂直拆分，我们都需要决定如何在视图之间传递数据。

想象一下，我们有一个微前端用于登录用户，另一个微前端用于在我们的平台上对用户进行身份验证。成功认证后，登录微前端必须将令牌传递到我们平台的认证区域。我们如何将令牌从一个微前端传递到另一个微前端？我们有几种选择。

我们可以使用类似网络存储的会话、本地存储或 cookie（见图 3-6）。在这种情况下，我们可能会使用本地存储来独立存储和检索令牌。加载微前端是因为 Web 存储始终可用且可访问，只要微前端位于同一子域中。

另一种选择可能是通过查询字符串传递一些数据。例如，在假设的 URL http://www.acme.com/products/details?id=123 中，问号后面的文本代表查询字符串——在这种情况下，选择的特定产品的“ID 123”由用户——并检索完整的详细信息以通过 API 显示（见图 3-7）。但是，使用查询字符串并不是传递密码和用户 ID 等敏感数据的最安全方式。如果该信息通过 HTTPS 协议传递，则有更好的方法来检索该信息。仔细接受这个解决方案。

总而言之，微前端决策框架由四个关键决策组成：识别、组合、路由和通信。在表 3-2 中，您可以根据您识别微前端的方式找到所有可用的组合。

|   Micro-frontends definition     |   Composition |   Routing| Communication |
| ----------- | ----------- |---------| ---------|
|   Horizontal     |   Client side       |  Client side |  Event emitter |
|        |   Edge-side       |Edge-side |  Custom event |
|        |   Server-side      | Server-side|  Web storage | 
|    | Voting system 投票系统|  
|  Generic subdomain   |  Sign-in or sign-up   |






