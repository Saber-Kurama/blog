# 微前端原理

在我职业生涯之初，我曾参与过许多软件项目，其中小型或中型团队正在开发一个单一的应用程序，该应用程序具有在单个工件中可用的平台的所有功能，以及在软件开发过程中产生的产品和 部署到 Web 服务器。

当我们有一个单体时，我们会编写很多应该和谐地协同工作的代码。 根据我的经验，我们倾向于预先优化甚至过度设计我们的应用程序逻辑。 抽象代码的可重用部分可以创建更复杂的代码库，有时维护复杂逻辑的努力从长远来看不会得到回报。 不幸的是，当时看起来很简单的东西在几个月后可能看起来非常笨拙。

在过去十年中，亚马逊网络服务 (AWS) 或谷歌云等公共云提供商开始受到关注。 如今，它们因将日益成为商品的事物委托给他人而广受欢迎，从而使组织能够专注于业务中真正重要的事情：为最终用户提供的服务。

尽管云系统允许我们以比以前更容易的方式扩展我们的项目，但不幸的是，单体应用不仅要求我们扩展系统的单个部分，而且还要求我们扩展整个系统，如果我们的系统没有模块化或编写高 标准。

此外，在具有分布式团队和托管团队的单体代码库上工作可能具有挑战性，尤其是在达到中型或大型团队规模之后，因为通信开销和集中决策，少数人为每个人做决定。

从长远来看，拥有大型单体的组织通常会减慢推进任何新功能所需的所有操作，失去他们在项目开始时一切都更容易、更小、几乎没有并发症和风险的巨大动力。 此外，对于单体应用程序，我们必须每次都部署整个代码库，这会增加在生产中破坏 API、引入新错误和犯更多错误的机会，尤其是当代码库不是坚如磐石或经过广泛测试时 . 为了解决员工面临的这些和许多其他挑战，公司可能会从复杂的单体代码库转向多个较小的代码库和称为微服务的范围域。

如今，微服务架构是世界各地许多组织使用的众所周知的成熟模式。 微服务将一个独特的代码库分成更小的部分，与单体架构相比，每个部分都有一个功能子集，在单体架构中，每个部分都是相互独立的，允许团队完全拥有和独立发展代码库。 这种业务逻辑被开发人员所接受，因为微服务解决的问题比查看数千行代码更简单。 与处理单一代码库相比，团队的认知负担有具体的减少。

另一个显着的优势是我们可以扩展应用程序的一部分，并为微服务使用正确的方法，而不是像单体应用那样千篇一律的方法。 但是，使用微服务也有一些陷阱。 必须完成对自动化、可观察性和监控的投资，才能控制分布式系统。 另一个陷阱是对微服务边界的错误定义，例如，微服务太小，无法完成依赖于其他微服务的系统内部的操作，从而导致服务之间的强耦合，并迫使它们每次部署在一起。 当这种现象扩展到多个服务时，我们可能会以一个大泥球或一个由于其复杂性而难以扩展的系统而告终。

微服务带来了许多好处，但也带来了许多缺点。 特别是，当我们在项目中采用它们时，拥有微服务架构的复杂性可能会变得痛苦多于益处。 考虑到软件开发中可用的架构数量，我们应该只在需要时选择微服务，而不是仅仅因为它是最新最好的方法就鲁莽地选择它们。

与我们过去在 Web 开发中采用的单一方法相比，微前端是一种沿着业务和职责边界定义软件交付的新兴方法。 但是请记住，微服务和微前端都不是所有软件分解的通用答案。 要了解它们适合的位置，甚至它们是什么，让我们看看推动我们朝这个方向发展的一些力量。

## 单体到微服务

当我们开始一个新项目甚至是一个提供在线服务的新业务时，应该使用第一次迭代来了解我们的业务是否能够成功。 通常，我们首先确定我们团队熟悉的技术堆栈（用于构建和运行单个应用程序的技术服务列表）。 通过最大限度地减少系统周围的花里胡哨并专注于最低限度，我们能够直接从用户那里快速收集有关我们商业理念的信息。 这也称为 MVP 或最小可行产品。

通常，我们将 API 层设计为一个独特的代码库（单体），因此我们需要为项目设置一个持续集成或持续交付管道。 在单体应用程序中集成可观察性非常容易； 我们只需要为每个虚拟机或容器运行一个代理来检索我们的应用程序服务器的健康状态。 部署过程很简单，考虑到我们需要为整个 API 层处理一种自动化策略和一种部署和发布策略，当流量开始增加时，我们可以水平扩展我们的机器，拥有尽可能多的应用程序服务器来实现 用户的请求。 这也是为什么单体架构通常是新项目的好选择，因为我们可以更多地关注应用程序的业务逻辑，而不是在其他方面投入太多精力，例如自动化。

我们将在哪里存储我们的数据？ 我们必须决定哪个数据库更适合我们的项目需求——graph、NoSQL 还是 SQL 数据库？ 另一个必须做出的决定是我们是否希望将我们的数据库托管在云服务或本地。 我们应该选择更适合我们的业务案例的数据库。 例如，如果我们需要创建一个具体的数据视图来填充用户界面，那么拥有一个 NoSQL 数据库可能比任何其他数据库都更有意义。 同时，我们可以说使用图数据库来映射用户之间的关系，就像在社交网络应用程序中一样，更适合这种数据库。

最后，我们需要选择一种技术来表示我们的数据，例如在浏览器或移动应用程序中。 我们可以选择最知名的 JavaScript 框架或我们最喜欢的编程语言； 我们可以决定使用服务器端渲染还是 SPA 架构； 然后我们定义我们的代码约定、linting 和 CSS 规则。

最后，我们应该得到如图 2-1 所示的结果。

 


希望我们项目背后的商业理念和目标能够得到验证，更多的用户将订阅我们的在线服务或购买我们销售的产品。

###  转向微服务

现在想象一下，由于我们系统的成功，我们公司决定扩大技术团队，雇佣更多的工程师、QA、Scrum Master 等等。 在监控我们的日志和仪表板时，我们意识到并非所有 API 都在有机地扩展。 其中一些是高度可缓存的，因此 CDN 为绝大多数客户端提供服务。 只有当我们的 API 不可缓存时，我们的原始服务器才会承受压力。 幸运的是，它们并不是我们所有的 API，只是其中的一小部分。

考虑到内部增长和我们对系统如何工作的更好理解，此时拆分我们的单体变得更有意义。

拥抱微服务还意味着审查我们的数据库策略，因此拥有多个不跨微服务共享的数据库； 如果需要，我们的数据会被部分复制，因此每个微服务都会减少返回响应的延迟。 突然之间，我们正朝着一个具有许多活动部件的一致生态系统迈进，这些部件提供了比以前更高的敏捷性和更低的风险。

每个团队负责其一组微服务。 团队成员可以决定要选择的最佳数据库、构建模式的最佳方式、如何缓存一些信息以使响应更快，以及为工作选择哪种编程语言。 基本上，我们正在进入一个每个团队都有权做出决策并负责他们在生产中运行的服务的世界，除了关键决策（如日志记录和监控）之外，不需要整个系统的通用解决方案 ，如图 2-2 所示。



但是，我们仍然在这里遗漏了一些东西。 我们能够通过定义明确的模式和最佳实践来扩展 API 层和持久层，但是当我们的业务增长并且我们也需要扩展前端团队时会发生什么？


### 介绍微前端

从历史上看，在前端我们没有太多的选择来扩展我们的应用程序，原因有几个。 直到几年前，还没有强烈的需要这样做，因为拥有一个运行所有业务逻辑的胖服务器和一个用于显示服务器提供的计算结果的瘦客户端是标准 方法。

在过去的几年里，这种情况发生了很大变化。 我们的用户在浏览我们的网络平台时正在寻求更好的体验，包括更多的交互性和更好的交互。 以订阅模式提供服务的公司已经出现，许多人正在接受这些服务。 现在，观看点播视频而不是线性频道，在应用程序中收听我们最喜欢的音乐而不是购买 CD，从移动应用程序订购食物而不是打电话给餐厅，都是很正常的。

这种行为转变要求我们改善用户体验，并提供一条顺畅的途径来完成用户的需求，而不会忘记高质量的内容或服务。 过去，我们会通过在共享组件库中划分应用程序的各个部分、在其他库中抽象一些业务逻辑以便可以在应用程序的不同部分重用它们来解决这些问题。 一般来说，我们会尝试尽可能多地重用代码。

我并不是在反对那些仍然有效且与许多项目完美契合的解决方案，但我们在接受它们时会遇到很多挑战。 例如，当我们有一个中型或大型开发团队时，应用于代码库的所有规则通常都是一次决定，我们会坚持几个月甚至几年，因为改变一个决定需要整个 代码库，并成为组织的一大笔投资。 此外，由于缺乏时间、理想的一致性或只是懒惰，在开发过程中做出的许多决定可能会导致权衡取舍。 我们必须考虑到，一项业务，就像技术一样，以一定的速度发展，这是不可避免的。

代码抽象也不是灵丹妙药。 过早地抽象代码以供重用通常会导致更多的问题而不是好处。 我经常看到抽象使代码比必要的复杂数千倍，只能在同一个项目中重复使用两次。 许多开发人员倾向于过度设计某些解决方案，认为他们会重复使用它们数十甚至数百次，但实际上他们使用它们的次数要少得多。 在多个项目和团队中使用库最终可能会产生比好处更多的复杂性，例如使代码库更复杂或需要更多的手动测试工作或增加通信开销。

我们还需要考虑前端的单体方法。 从长远来看，这种方法不会让我们改进我们的架构，特别是如果我们正在开发旨在为我们的用户提供多年的平台，或者如果我们在不同时区有分布式团队。

要求任何企业广泛修改其使用的技术将导致在获得任何结果之前进行大量投资。 现在问题变得非常明显：我们是否有机会使用众所周知的模式或架构，从而提供快速添加新功能、随业务发展并自主交付部分应用程序而无需大爆炸式发布的可能性？

我描绘了类似于图 2-3 的图像。

答案是肯定的，我们绝对可以做到，这就是微前端来拯救的地方。 当我们与大中型公司打交道时，这种架构更有意义，在接下来的章节中，我们将探索如何成功地构建我们的微前端架构。 但是，首先我们需要了解背后的主要原则是什么
在我们的项目开发过程中，微前端可以作为指导。

## 微服务原则

在开始我的微前端之旅时，我从技术方面退后一步，研究了其他架构背后的原则，用于扩展软件项目。 这些原则也适用于前端吗？ 微服务的原则提供了很多有用的概念。 Sam Newman 在他的书 Building Microservices (O'Reilly) 中强调了这些想法。 我在图 2-4 中总结了这些理论。

让我们讨论这些原则，看看它们如何应用于前端。

###  Modeled Around Business Domains 围绕业务领域建模

围绕业务领域建模是领域驱动设计 (DDD) 提出的一个关键原则。 它首先假设每个软件都应该反映组织所做的事情，并且我们应该基于域和子域来设计我们的架构，利用在整个业务中共享的无处不在的语言。 从业务角度工作时，这提供了几个好处，包括更好地理解系统、更容易定义业务领域的技术表示，以及团队应遵循的明确界限。 我们将在接下来的章节中广泛讨论这个话题。

### Culture of Automation 自动化文化

考虑到微服务是大量应该是自治的服务，我们需要一种在不同环境中自动部署独立单元的强大文化。 以我的经验，这是利用微服务架构的关键过程； 拥有强大的自动化文化使我们能够以可靠的方式更快地行动。

### Hide Implementation Details 隐藏实施细节

在自主发布时隐藏实现细节至关重要。 如果我们在微服务之间共享数据库，我们将无法在不影响所有依赖原始模式的微服务的情况下更改数据库模式。 DDD 教我们如何将服务封装在同一个业务域中，只通过 API 公开需要的内容，并隐藏其余的实现。 这使我们能够按照自己的节奏更改内部逻辑，而不会影响系统的其余部分。

### Decentralize Governance  去中心化治理

分散治理使开发人员能够在正确的阶段做出正确的决定来解决问题。 对于单体架构，许多关键决策通常由组织中最有经验的人做出。 然而，这些决定经常导致软件生命周期的权衡。 分散这些决策可能会对整个系统产生积极影响，因为它允许团队采取技术
根据他们面临的问题来指导，而不是为整个系统制造妥协。

### Deploy Independently 独立部署

独立部署是微服务的关键。 对于单体应用，我们习惯于每次都部署整个系统，存在更大的实时问题风险以及更长的部署和回滚工件的时间。 但是，使用微服务，我们可以自主部署，而不会增加破坏整个 API 层的可能性。 此外，我们拥有可靠的技术，例如蓝绿部署或金丝雀发布（第 6 章会详细介绍），它们允许我们以更低的风险发布新版本的微服务，从而为新的或更新的 API 扫清道路

### Isolate Failure 隔离失败隔离失败

因为我们将一个整体拆分成数十个（如果不是数百个）服务，如果一个或多个微服务由于网络问题或服务故障而变得无法访问，那么系统的其余部分应该可供我们的用户使用。 有几种模式可以为微服务提供优雅的故障，它们是自主和独立的这一事实强化了隔离故障的概念。

### Highly Observable 高度可观察

与微服务相比，您更喜欢单体架构的一个原因是，观察单个系统比将系统拆分为多个服务更容易。 微服务提供了很大的自由度和灵活性，但这并不是免费的； 我们需要通过日志、监视器等来关注一切。 例如，我们必须准备好在我们的系统中端到端地跟踪特定的客户端请求。 保持系统高度可观察是微服务的主要挑战之一。

在微服务环境中接受这些原则不仅需要改变您的软件架构，还需要改变公司的组织方式。 它涉及从集中式范式转变为分散式范式，使跨职能团队能够端到端地拥有他们的业务领域。 对于大中型组织来说，这可能是一个特别巨大的变化。

## 将原则应用于微前端

现在我们已经掌握了微服务背后的原理，让我们来看看如何将它们应用到前端应用程序中。

### Modeled Around Business Domains  围绕业务领域建模

为遵循 DDD 原则的微前端建模不仅是可能的，而且非常有价值。 当您在未来添加新功能或偏离最初的项目愿景时，在项目开始时投入时间来识别不同的业务领域以及如何划分应用程序将很有用。 DDD 可以为管理后端项目提供明确的方向，但我们也可以在前端应用其中一些技术。 授予团队对其业务领域的完全所有权可能非常强大，尤其是当产品团队有权与技术团队合作时。

### Culture of Automation 自动化文化

至于微服务架构，我们不能承受组织内部糟糕的自动化文化； 否则，我们将采取的任何微前端方法最终都会成为我们所有团队的噩梦。 考虑到每个微前端项目都包含数十或数百个不同的部分，我们必须确保我们的持续集成和部署管道是可靠的，并且有一个快速的反馈循环来拥抱这个架构。 花时间使我们的自动化正确，将导致微前端的顺利采用。

### Hide Implementation Details 隐藏实施细节

隐藏实现细节和使用合约是两种基本做法，尤其是当我们的应用程序的某些部分需要相互通信时。 预先定义团队之间的合同并让各方在整个开发过程中尊重这一点至关重要。 通过这种方式，除非 API 合同发生变化，否则每个团队都可以在不影响其他团队的情况下更改实施细节。 这些实践允许团队专注于内部实施细节，而不会干扰其他团队的工作。 每个团队都可以按照自己的节奏工作，而无需外部依赖，从而创建更有效的集成。

### Decentralize Governance 去中心化治理

分散团队的决策最终使我们摆脱了一种千篇一律的方法，这种方法通常最终成为最小的公分母。 相反，团队将使用正确的方法或工具来完成这项工作。 与微服务一样，当团队成为业务领域的专家时，团队处于做出某些决策的最佳位置。 这并不意味着每个团队都应该有自己的方向，而是技术领导层（架构师、首席工程师、首席技术官）应该提供一些护栏，团队可以在这些护栏之间进行操作，而无需等待中央决策。 这导致组织内部的共享文化对于在团队间引入成功实践至关重要。

### Deploy Independently 独立部署

微前端允许团队以自己的速度部署独立的工件。 他们不需要在部署之前等待解决外部依赖关系。 当我们将这种方法与微服务相结合时，团队可以拥有端到端的业务领域，并能够根据其业务领域内的挑战做出技术决策，而不是寻找一种万能的方法。

### Isolate Failure 隔离失败

由于其架构，隔离 SPA 中的故障并不是一个大问题，但它与微前端有关。 事实上，微前端可能需要在运行时编写用户界面，这可能会导致网络故障或一个或多个文件的 404。 为避免影响用户体验，我们必须提供替代内容或隐藏应用程序的特定部分。

### Highly Observable 高度可观察









