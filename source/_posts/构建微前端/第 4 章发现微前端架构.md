# 发现微前端架构
在上一章中，我们了解了决策框架，这是任何微前端架构的基础。在本章中，我们将回顾不同的架构选择，应用我们目前所学的知识。

## 应用微前端决策框架

决策框架可帮助您根据微前端项目的特点选择正确的方法（见图 4-1）。您的第一个决定将是在水平和垂直拆分之间


###  Vertical Split

垂直拆分提供的选择较少，而且由于习惯于编写单页应用程序 (SPA) 的前端开发人员很可能熟悉它们，因此图 4-1 仅显示了客户端的选择。当您的项目需要一致的用户界面演变和跨多个视图的流畅用户体验时，您会发现垂直拆分很有帮助。这是因为垂直拆分提供了最接近 SPA 的开发人员体验，因此工具、最佳实践和模式可用于微前端的开发。

尽管从技术上讲，您可以使用任何组合来服务垂直拆分的微前端，但到目前为止，所有探索的实现都有一个客户端组合，其中应用程序外壳负责安装和卸载微前端，给我们留下了一种组合方法可供选择从。微前端和应用程序外壳之间的关系始终是一对一的，因此应用程序外壳一次只加载一个微前端。您还需要使用客户端路由。路由通常分为两部分，全局路由用于加载由应用程序外壳处理的不同微前端（见图 4-2）。

尽管同一微前端内部视图之间的本地路由由微前端本身管理，但您将完全控制其中存在的视图的实现和演变，因为负责微前端的团队也是应用程序业务领域的主题专家（图 4-3）。

最后，为了实现一个垂直分割的微前端架构，应用程序外壳加载 HTML 或 JavaScript 作为入口点。应用程序外壳不应与其他微前端共享任何业务领域逻辑，并且应该与技术无关以允许未来的系统演进，因此您不希望使用任何特定的 UI 框架来构建应用程序外壳。如果您构建了自己的实现，请尝试使用 Vanilla JavaScript。

应用程序外壳始终存在于用户会话期间，因为它负责编排 Web 应用程序以及为微前端公开一些生命周期 API，以便在它们完全安装或卸载时做出反应。

当垂直拆分的微前端必须与其他微前端共享信息时，例如令牌或用户偏好，我们可以使用查询字符串来获取易失性数据，或者使用 Web 存储来获取令牌或用户偏好，类似于水平拆分的方式不同观点之间。

### Horizontal Split

当业务子域应该在多个视图中呈现时，水平拆分效果很好，因此子域的可重用性成为项目的关键；当搜索引擎优化是您项目的关键要求并且您想使用服务器端渲染方法时；当您的前端应用程序需要数十甚至数百名开发人员一起工作并且您必须更细化地拆分我们的子域时；或者当您在软件的特定部分有一个客户自定义的多租户项目时。

您将做出的下一个决定是在客户端、边缘端和服务器端组合之间做出决定。例如，当您的团队更熟悉前端生态系统或者当您的项目受到高流量和显着峰值的影响时，客户端是一个不错的选择。您将避免处理前端层的可扩展性挑战，因为您可以利用内容交付网络 (CDN) 轻松缓存微前端。

您可以对具有静态内容和高流量的项目使用边缘组合，以便将可扩展性挑战委托给 CDN 提供商，而不必在您的基础设施中处理它。正如我们在第 3 章中所讨论的，采用这种架构风格存在一些挑战，例如其复杂的开发人员体验以及并非所有 CDN 都支持它的事实。但是像没有个性化内容的在线目录这样的项目可能是这种方法的一个很好的候选者。

服务器端组合为我们提供了对输出的最大控制权，这对于高度索引的网站（例如新闻网站或电子商务）非常有用。对于需要出色性能指标的网站来说，它也是一个不错的选择，例如 PayPal 和 American Express，它们都使用服务器端组合。

接下来是您的路由策略。虽然您可以在技术上将任何路由应用于任何组合，但通常使用与您选择的组合模式相关的路由策略。例如，如果您选择客户端组合，大多数情况下，路由将发生在客户端级别。您可以在边缘使用计算逻辑（在 AWS 或 CloudFlare 中使用 Lambda@Edge）以避免金丝雀版本污染应用程序外壳的代码，或利用动态渲染向搜索引擎爬虫提供 Web 应用程序的优化版本能力。

另一方面，边缘合成将有一个与每个视图关联的 HTML 页面，因此每次用户加载新页面时，都会在 CDN 中合成一个新页面，CDN 将检索多个微前端来创建该页面最后的看法。最后，通过服务器端路由，应用服务器将知道哪个 HTML 模板与特定路由相关联；路由和组合发生在服务器端。

您的组合选择也将有助于缩小您构建微前端项目的技术解决方案。当您使用客户端组合和路由时，最好的实现选择是应用程序 shell 在同一个视图中加载多个微前端，例如，使用名为 Module Federation 的 webpack 插件、iframe 或 web 组件。

对于边缘组合，唯一可用的解决方案是使用边缘包含 (ESI)。随着云提供商扩展其边缘服务以提供更多计算和存储资源，我们看到了未来可能会改变的迹象。不过，目前，ESI 是唯一的选择。当您决定使用服务器端组合时，您可以为您的微前端应用程序使用服务器端包含 (SSI) 或众多 SSR 框架之一。请注意，SSR 将为您提供更大的灵活性并控制您的实施。

决策框架中缺少最后一个支柱：当微前端处于相同或不同视图时，它们将如何通信。这主要是因为当你选择水平拆分时，你必须避免跨微前端共享任何状态；这种方法是一种反模式。相反，您将使用第 3 章中提到的技术，例如事件发射器、自定义事件或使用发布/订阅 (pub/sub) 模式实现的反应流，以解耦微前端并保持它们的独立性.当您必须在不同视图之间进行通信时，您将使用查询字符串参数来共享易失性数据，例如产品标识符，以及用于持久数据的 Web 存储/cookie，例如用户令牌或本地用户设置。

>  观察者模式
 观察者模式（也称为发布/订阅模式）是一种行为设计模式，它定义了对象之间的一对多关系，这样，当一个对象更改其状态时，所有相关对象都会得到通知并自动更新。与对其状态感兴趣的其他对象具有一对多关系的对象称为主题或发布者。它的依赖对象称为观察者或订阅者。每当主题的状态发生变化时，观察者都会收到通知，然后他们会采取相应的行动。主体可以有任意数量的依赖观察者。


##  Architecture Analysis 架构分析

为了帮助您更好地为您的项目选择正确的架构，我们现在将分析技术实现，着眼于挑战和好处。我们将详细审查不同的实现，然后评估每种架构的特征。我们将为每个实现分析的特征：

Deployability  可部署性

在环境中部署微前端的可靠性和易用性。

Modularity  模块化

易于添加或删除微前端，易于与微前端托管的共享组件集成。

Simplicity  简单

易于理解或做事。如果一个软件被认为是简单的，那么它很可能被发现很容易理解和推理。

Testability 可测试性

软件工件在给定测试环境中支持测试的程度。如果软件工件的可测试性高，那么通过测试来发现系统中的故障就更容易了。

Performance 表现

微前端如何满足 Web Vitals 所描述的用户体验质量的指标，这是一个健康网站的基本指标。

Developer experience  开发者经验

开发人员在使用您的产品时所获得的体验，无论是客户端库、SDK、框架、开源代码、工具、API、技术还是服务。

Scalability 可扩展性

流程、网络、软件或组织增长和管理不断增长的需求的能力。

Coordination 协调

统一、整合或同步团队成员的努力，以便在追求共同目标的过程中提供统一的行动。


特征以五分制进行评分，一分表示特定的架构特征没有得到很好的支持，五分表示架构特征是架构模式中最强的特征之一。该分数表明哪种架构特征在所描述的每种方法中表现得更好。由于它们彼此之间的紧张关系，几乎不可能让所有特征在架构中完美地工作。我们的角色是找到适合我们必须构建的应用程序的权衡，因此决定创建一个评分机制来评估所有这些架构方法。

### 架构和权衡

正如我在本书其他地方所指出的，我坚信完美的架构并不存在。这总是一个权衡。权衡不仅是技术上的，还取决于业务需求和组织结构。现代建筑考虑了有助于最终结果的其他力量以及技术方面。我们必须认识到社会技术方面并针对我们所处的环境进行优化，而不是寻找“完美的架构”（不存在）或从另一个环境中借用架构而不研究它是否适合我们的环境。

在《软件架构基础》一书中，Neal Ford 和 Mark Richards 很好地强调了这些新的架构实践，并邀请读者针对“最不差”的架构进行优化。正如他们所说，“永远不要追求最好的架构，而要追求最不差的架构。”

在确定最终架构之前，请花时间了解您所处的环境、团队的结构以及团队之间的沟通流程。当我们忽略这些方面时，我们就有可能创建一个完全不适合我们公司的伟大技术主张。当我们阅读其他采用特定架构的公司的案例研究时，情况也是如此。我们需要了解公司的运作方式以及与我们公司的运作方式相比如何。案例研究通常侧重于公司如何解决特定问题，这可能与您的挑战和目标重叠，也可能不重叠。由您来确定案例研究的挑战是否与您自己的挑战相匹配。

广泛阅读并与社区中的不同人交谈，以了解某些决定背后的力量。花时间研究将帮助您避免做出错误的假设，并更加了解您所处的环境。

每个架构都针对解决特定的技术和组织挑战进行了优化，这就是为什么我们看到如此多的微前端方法。请记住：架构没有对错之分，只是根据您自己的环境进行的最佳权衡。

##  Vertical-Split Architectures 垂直拆分架构

对于垂直拆分架构，客户端组合、客户端路由和应用程序外壳，如上所述，对于具有构建 SPA 以首次涉足微前端的坚实背景的团队来说非常棒，因为开发经验将是最熟悉的。这
对于有前端背景的开发者来说，这可能也是进入微前端世界的最简单方式。

###  Application Shell

作为微前端应用程序的持久部分，应用程序外壳是请求应用程序时首先下载的内容。它将从头到尾引导用户会话，根据用户请求的端点加载和卸载微前端。在应用程序外壳中加载微前端的主要原因包括：

处理初始用户状态（如果有）

如果用户尝试通过深度链接访问经过身份验证的路由，但用户令牌无效，则应用程序外壳会将用户重定向到登录视图或登录页面。但是，只有第一次加载才需要此过程。之后，Web 应用程序经过身份验证的区域中的每个微前端都应管理保持用户身份验证或将用户重定向到未经身份验证页面的逻辑。

 
Retrieving global configurations 检索全局配置

需要时，应用程序外壳应首先获取包含在整个用户会话中使用的任何信息的配置，例如，如果应用程序根据国家/地区提供不同的体验，则用户所在的国家/地区。


Fetching the available routes and associated micro-frontends to load 获取要加载的可用路由和相关的微前端

为了避免不必要地部署应用程序外壳，路由配置应该在运行时与相关的微前端一起加载。这将保证对路由系统的控制，而无需多次部署应用程序外壳。


Setting logging, observability, or marketing libraries 设置日志记录、可观察性或营销库

因为这些库通常应用于整个应用程序，所以最好在应用程序 shell 级别实例化它们。


Handling errors if a micro-frontend cannot be loaded 如果无法加载微前端，则处理错误

有时，由于网络问题或系统中的错误，微前端无法访问。向应用程序外壳添加错误消息（例如 404 页面）或加载高可用性微前端以显示错误并向用户建议可能的解决方案是明智的，例如建议类似产品或要求他们稍后再来。


您可以通过在每个微前端中使用库而不是使用像应用程序外壳这样的编排器来获得类似的结果。但是，理想情况下，您只需要一个地方来管理这些事情。拥有多个库意味着确保它们在微前端之间始终保持同步，这需要更多的协调并增加整个过程的复杂性。与将库集中在应用程序外壳内相比，拥有多个库也会在部署阶段产生风险，在部署阶段会发生重大变化。

切勿在用户会话期间将应用程序外壳用作与微前端不断交互的层。应用程序外壳应仅用于边缘情况或初始化。将其用作微前端的共享层可能会导致微前端和应用程序外壳之间存在逻辑耦合，从而强制测试和/或重新部署应用程序中可用的所有微前端。这种情况也称为分布式单体，是开发人员最糟糕的噩梦。

在这种模式下，应用程序外壳一次只加载一个微前端。这意味着您不需要创建一种机制来封装微前端之间的冲突依赖项，因为不会有
库或 CSS 样式之间的任何冲突（见图 4-4），只要在卸载微前端时两者都从窗口对象中删除。

应用程序外壳只不过是一个简单的 HTML 页面，其逻辑包装在一个 JavaScript 文件中。某些 CSS 样式可能包含在应用程序外壳中，也可能不包含在初始加载体验中，例如用于显示像微调器这样的加载动画。每个微前端入口点都由包含单个视图的逻辑和样式的单个 HTML 页面或包含多个路由的小型 SPA 表示，这些路由包含允许用户使用应用程序的整个子域所需的所有逻辑，而无需新的需要加载的微前端。可以加载 JavaScript 文件作为微前端入口点，但在这种情况下，我们受到初始客户体验的限制，因为我们必须等到 JavaScript 文件被解释后才能将新元素添加到域对象模型中（DOM）。

当我们想要创建一致的用户体验同时为单个团队提供完全控制时，垂直拆分效果很好。一个明显的迹象表明，这可能是您的应用程序的正确方法，当您在多个视图中没有很多业务子域重复但应用程序的每个部分都可能由应用程序本身表示时。

当我们清楚地了解用户如何与应用程序交互时，识别微前端变得很容易。如果您使用 Google Analytics 等分析工具，您将可以访问这些信息。如果您没有此信息，则需要先获取它，然后才能确定如何构建架构、业务领域和您的组织。在这种架构下，微前端的可重用性不高，因此垂直拆分的微前端不太可能在同一个应用程序中被多次重用。

然而，在每个微前端中，我们都可以重用组件（想想设计系统），生成有助于避免过多重复的模块化。不过，微前端更有可能在同一家公司维护的不同应用程序中重复使用。想象一下，在多租户环境中，您必须开发多个平台，并且您希望拥有一个类似的用户界面，并针对每个平台的一部分进行一些自定义。您将能够重用垂直拆分的微前端，减少代码碎片并根据业务需求独立发展系统。

###  Challenges 挑战

当然，在实施阶段会遇到一些挑战，就像任何架构模式一样。除了特定领域的挑战之外，我们还会遇到一些共同的挑战，其中一些有直接的答案，而另一些则更多地取决于上下文。让我们看看四个主要挑战：共享状态、微前端组合、多框架方法以及架构的演变。

####  Sharing state

一般来说，当我们使用微前端时，我们面临的第一个挑战是如何在微前端之间共享状态。虽然我们不需要与垂直拆分架构共享太多信息，但这种需求仍然存在。

我们可能需要跨多个微前端共享的一些信息在通过 Web 存储存储时很好，例如用户播放的媒体的音量级别或最近用于编辑文档的字体。

当信息更敏感时，例如个人用户数据或身份验证令牌，我们需要一种方法从公共 API 检索此信息，然后在所有对此信息感兴趣的微前端共享。在这种情况下，在用户会话开始时加载的第一个微前端将检索此数据，并存储在带有检索时间戳的 Web 存储中。然后每个需要此数据的微前端都可以直接从 Web 存储中检索它，如果时间戳早于预设的时间量，则微前端可以再次请求数据。并且由于应用程序一次只加载一个微前端，并且每个微前端都可以访问所选的 Web 存储，因此没有强烈要求通过应用程序外壳将数据存储在 Web 存储中。

但是，假设您的应用程序严重依赖 Web 存储，并且您决定实施安全检查以验证可用空间或存储的消息类型。在这种情况下，您可能希望通过应用程序外壳创建一个抽象，该外壳将公开一个用于存储和检索数据的 API。这将集中数据验证发生的位置，为每个微前端提供有意义的错误，以防验证失败。

#### Composing micro-frontends  组成微前端

您有多种选择可以在应用程序外壳中组合垂直拆分的微前端。但是请记住，垂直分割的微前端仅在客户端组成和路由，因此我们仅限于浏览器标准为我们提供的内容。在客户端组成微前端有四种技术：

#####  ES modules

JavaScript 模块可用于将我们的应用程序拆分为较小的文件，以便在编译时或运行时加载，在现代浏览器中完全实现。这可以是在运行时使用标准组合微前端的可靠机制。要实现 ES 模块，我们只需在 script 标签中定义 module 属性，浏览器会将其解释为模块：

``` js
 <script type="module" src="catalogMFE.js"></script>
```

该模块将始终被延迟，并且可以实现跨域资源共享 (CORS) 身份验证。 ES 模块也可以在导入映射中为整个应用程序定义，允许我们使用语法在应用程序中导入模块。截至发布时，导入地图的主要问题是并非所有浏览器都支持它们。您将受限于 Google Chrome、Microsoft Edge（带有 Chromium 引擎）和最新版本的 Opera，从而限制了该解决方案的可行性。

#####  SystemJS

此模块加载器支持导入地图规范，这些规范在浏览器中本机不可用。这允许它们在 SystemJS 实现中使用，其中模块加载器库使实现与所有浏览器兼容。当我们希望我们的微前端在运行时加载时，这是一个方便的解决方案，因为它使用类似于导入地图的语法并允许 SystemJS 处理浏览器的 API 碎片。


#####  Module Federation

这是 webpack 5 中引入的一个插件，用于加载外部模块、库，甚至是另一个应用程序中的整个应用程序。该插件负责组合微前端所需的无差别繁重工作，包装微前端的范围并在不同微前端之间共享依赖关系或处理同一库的不同版本而不会出现运行时错误。开发人员的体验和实现非常流畅，看起来就像编写一个普通的 SPA。每个微前端都作为一个模块导入，然后以与 UI 框架的组件相同的方式实现。这个插件所做的抽象使得整个作曲挑战几乎完全无痛。

##### HTML解析

当微前端有一个由 HTML 页面表示的入口点时，我们可以使用 JavaScript 来解析 DOM 元素并将所需的节点附加到应用程序外壳的 DOM 中。最简单的 HTML 文档实际上只是一个具有自己定义的模式的 XML 文档。鉴于此，我们可以将微前端视为 XML 文档，并使用 DOMParser 对象将相关节点附加到 shell 的 DOM 中。在解析完微前端 DOM 之后，我们使用adoptNode 或cloneNode 方法附加DOM 节点。但是，使用 cloneNode 或采用节点不适用于 script 元素，因为浏览器不会评估 script 元素，所以在这种情况下，我们创建一个新的，传递在微前端的 HTML 页面中找到的源文件。创建新的脚本元素将触发浏览器全面评估与
这个元素。通过这种方式，您甚至可以简化微前端开发人员的体验，因为您的团队将提供知道初始 DOM 外观的最终结果。这种技术被一些框架使用，例如 qiankun，它允许 HTML 文档成为微前端的入口点。


在客户端组成的所有主要框架都实现了这些技术，有时您甚至可以选择。例如，对于单个 SPA，您可以使用 ES 模块、带有导入映射的 SystemJS 或模块联合。

所有这些技术都允许您实现静态或动态路由。在静态路由的情况下，您只需在代码中硬编码路径。使用动态路径，您可以从静态 JSON 文件中检索所有路由以在应用程序开始时加载，或者通过开发可由应用程序外壳使用的端点以及根据用户所在国家/地区应用逻辑的端点来创建更动态的东西或返回最终路由列表的语言。

####  Multiframework approach 多框架方法

将微前端用于多框架方法是一个有争议的决定，因为许多人认为这会迫使他们使用多个 UI 框架，例如 React、Angular、Vue 或 Svelte。但是对于以单体方式编写的前端应用程序而言，对于微前端也是如此。

尽管从技术上讲，您可以在 SPA 中实现多个 UI 框架，但它会产生性能问题和潜在的依赖冲突。这也适用于微前端，因此不建议为这种架构风格使用多框架实现。

相反，请遵循最佳实践，例如尽可能减少外部依赖项，仅导入您使用的内容，而不是可能增加最终 JavaScript 包的整个包。许多 JavaScript 工具实现了 tree-shaking 机制来帮助实现更小的包大小。

在某些用例中，使用微前端的多框架方法带来的好处超过了挑战，例如，我们何时可以为开发人员创建一个健康的飞轮，在不影响生产流量的情况下缩短其业务逻辑的上市时间。

想象一下，您开始将前端应用程序从 SPA 移植到微前端。 在微前端上工作并同时部署 SPA 代码库将帮助您为您的业务和用户提供价值。

首先，我们将有一个团队寻找实现移植的最佳实践（例如识别要跨微前端重用的库）、设置自动化管道、在微前端之间共享代码等等。 其次，在创建最小可行产品（MVP）之后，可以将微前端交付给最终用户，检索指标并与旧版本进行比较。 在这种情况下，要求用户下载多个 UI 框架比开发新架构几个月而不了解方向是否会带来更好的结果更容易解决问题。 验证您的假设对于生成组织内不同团队共享的最佳实践至关重要。 改进反馈循环并尽快将代码部署到生产环境中，这展示了总体上克服微架构未来挑战的最佳方法。

您可以将相同的推理应用于同一应用程序中的其他库，但版本不同，例如当您有一个使用旧版本 Angular 的项目并且想要升级到最新版本时。

请记住，我们的目标是为自信地快速行动创造肌肉，减少潜在的错误，使可能发生的事情自动化，并在整个团队中培养正确的心态。 最后，这些考虑适用于本书分享的所有微前端架构。


####  Architecture evolution and code encapsulation 架构演进与代码封装

在第一次尝试时完美定义子域并不总是可行的。 特别是，使用垂直拆分方法可能会导致粗粒度的微前端在经过几个月的工作后变得复杂，因为随着团队能力的增长，项目范围会扩大。 此外，我们可以对我们在流程开始时所做的假设有新的见解。 不要害怕！ 该架构的模块化特性可帮助您应对这些挑战，并为与业务一起发展提供清晰的路径。 当您的团队的认知负荷开始变得不可持续时，可能是时候拆分您的微前端了。 拆分微前端的众多最佳实践之一是代码封装，它基于特定的用户流。 让我们来探索一下吧！

封装的概念来自面向对象编程（OOP），与类以及如何处理数据相关。 封装将属性（数据）和操作数据的方法（函数和过程）绑定在一起，以保护数据。 许多语言强制执行的一般规则是，只能使用包含（封装）在类定义中的方法来访问（即检索或修改）属性。

想象一下，你的微前端由几个视图组成，例如支付表单、注册表单、登录表单、电子邮件和密码检索表单，如图 4-5 所示。

图 4-5。 由多个视图组成的身份验证微前端可能会给负责该微前端的团队带来高认知负荷

访问此微前端的现有用户更有可能登录已验证区域或想要检索其帐户电子邮件或密码，而新用户可能会注册或付款。 因此，这个微前端的自然拆分可能是一个用于身份验证的微前端和另一个用于订阅的微前端。 这样，您将根据业务逻辑将两者分开，而无需要求用户下载比流程所需的更多代码（参见图 4-6）。

图 4-6。 拆分身份验证微前端以减少认知负担，关注客户体验而不是技术限制

这不是拆分此微前端的唯一方法，但是无论您如何拆分它，请确保您优先考虑业务成果而不是技术成果。 优先考虑客户体验是提供用户喜欢的最终输出的最佳方式。

封装有助于解决这些情况。 例如，避免使用代表整个微前端的唯一状态。 相反，更喜欢允许组合状态的状态管理库，比如 MobX-State-Tree。 数据将以树形结构表示，您可以随意组合。 花时间评估如何实现应用程序状态，您可以在以后节省时间，同时也减少您的认知负担。 当代码在某些边界内被很好地识别时，总是比当它分布在应用程序的多个部分时更容易思考。

当在多个域中使用库甚至逻辑时，例如在表单验证库中，您有几个选择：

#####  Duplicate the code 复制代码

代码重复并不总是一个坏习惯。这取决于您要优化的内容以及重复代码的整体影响。假设您有一个组件，该组件根据用户状态和托管它的视图具有不同的状态，并且该组件在一个域中比在其他域中更频繁地受到新需求的影响。您可能想要集中它。但是请记住，每次您拥有一个集中式库或组件时，您都必须建立一个可靠的治理，以确保在更新此共享代码时，它也会在使用此共享代码的每个微前端中得到更新好。发生这种情况时，您还必须确保新版本不会破坏每个微前端内部的任何内容，并且您需要协调多个团队之间的活动。在这种情况下，该组件并不难实现，并且对于每个使用它的团队来说构建起来会变得更容易，因为需要处理的状态更少。这允许每个实现以自己的速度独立发展。在这里，我们正在优化交付速度并减少每个团队的外部依赖。当您的重复数量有限时，这种方法最有效。当你有几十个类似的组件时，这种推理就不再适用了。你会想要抽象到一个库中。

##### Abstract your code into a shared library 将您的代码抽象到共享库中

在某些情况下，您确实希望集中业务逻辑以确保每个微前端都使用相同的实现，就像集成支付方式一样。 想象一下，在您的结帐表单中实现多种付款方式及其验证逻辑、处理错误等。 复制系统如此复杂和微妙的部分是不明智的。 相反，创建共享库将有助于保持一致性并简化整个平台的集成。 在自动化管道中，您需要在每个微前端添加版本检查以查看最新的库版本。 不幸的是，虽然处理分布式系统可以帮助您扩展组织并快速交付，但有时您需要为了更大的利益实施某些实践。

#####  Delegate to a backend API 委托给后端 API

第三种选择是将公共部分委托给后端所有垂直拆分的微前端，从而为每个微前端提供一些业务逻辑的配置和实现。想象一下，您有多个微前端正在实现具有特定验证的输入字段，该验证足够简单，可以用正则表达式表示。您可能很想将逻辑集中在一个公共库中，但这意味着每次发生变化时都要强制更新此依赖项。考虑到逻辑很容易表示并且通用部分将使用相同的正则表达式，您可以在应用程序加载时将此信息作为配置字段提供，并通过 Web 存储将其提供给所有微前端。这样，如果你想改变正则表达式，你就不需要重新部署每个实现它的微前端。您只需更改
配置中的正则表达式，所有微前端都会自动使用最新的实现。

> 错误抽象的代码重复
> 许多业内知名人士已经开始意识到抽象代码并不总是有好处，尤其是从长远来看。 在某些情况下，代码重复会给过早或仓促的抽象带来更多好处。 此外，如果需要，可以轻松抽象出重复的代码； 一旦抽象出现在代码中，尝试摆脱抽象就更具挑战性。 如果您对此主题感兴趣，请阅读 Sandi Metz 于 2016 年发表的一篇博文“The Wrong Abstraction”。 Kent Dodds 的 AHA 编程或“避免仓促抽象”概念受到 Metz 在他的博客和演讲中描述的工作的强烈启发。 此外，众所周知的 DRY 原则（不要重复自己）似乎被许多开发人员误用，他们只是在代码中查找重复的代码行并将它们抽象出来。 在 Pragmatic Programmer (Addison-Wesley) 的第二版中，首次介绍了 DRY 原则，作者对这一点提供了很好的解释：
> 
> 在本书的第一版中，我们没有很好地解释我们所说的不要重复自己的意思。 许多人认为它只是指代码：他们认为 DRY 的意思是“不要复制和粘贴源代码行”。
   这是 DRY 的一部分，但它是一个很小且相当微不足道的部分。 DRY 是关于知识和意图的重复。 这是关于在两个不同的地方表达同一件事，可能以两种完全不同的方式。 [重点补充]

重要的是要明白没有解决方案适合所有事情。 考虑您的实现应该代表的上下文，并在您正在使用的护栏中选择最佳权衡。 你能从一开始就以这种方式设计微前端吗？ 潜在地，你可以有，但这个架构的重点是避免过早的抽象，优化快速交付，并在由于复杂性或只是方向改变而需要时改进架构。

### Implementing a Design System  实施设计系统

在像微前端这样的分布式架构中，设计系统似乎很难实现，但实际上技术实现与 SPA 中的设计系统并没有太大区别。 在考虑应用于微前端的设计系统时，想象一个由设计令牌、基本组件、用户界面库以及将所有这些部分托管在一起的微前端组成的分层系统，如图 4-7 所示。

第一层，设计标记，允许您捕获低级值，然后为您的产品创建样式，例如字体系列、文本颜色、文本大小以及我们最终用户界面中使用的许多其他特征。 通常，设计令牌列在 JSON 或 YAML 文件中，表达了我们设计系统的每个细节。

我们通常不会在不同的微前端分发设计令牌，因为每个团队都会以自己的方式实现它们，冒着在应用程序的某些区域而不是在其他区域引入错误的风险，增加了整个系统的代码重复，并且， 一般来说，会减慢设计系统的维护速度。 但是，在某些情况下，设计令牌可以作为创建以后迭代的一致性级别的初始步骤，基本组件在所有微前端之间共享。 通常，团队没有足够的空间在每个微前端内实现最终设计系统组件。 因此，如果您沿着这条路走，请确保您有时间和空间来迭代设计系统。

下一层是基本组件。 通常，这些组件不包含应用程序业务逻辑，并且完全不知道它们将在哪里使用。 因此，它们应该尽可能通用，例如标签或按钮，这将提供我们正在寻找的一致性以及在应用程序的任何部分中使用的灵活性。

这是集中跨多个微前端使用的代码的完美阶段。 通过这种方式，我们创建了 UI 所需的一致性，以允许每个团队在他们需要的级别上使用组件。

第三层是 UI 组件库，通常是基本组件的组合，其中包含一些可在给定域内重用的业务逻辑。 我们可能也想共享这些组件，但这样做要谨慎。 要维护的治理和组织结构可能会导致团队之间存在许多外部依赖关系，造成的挫败感大于效率。 一个例外是当存在需要大量迭代的复杂 UI 组件并且有一个集中的团队负责它们时。 例如，想象一下构建一个复杂的组件，例如具有多种功能的视频播放器，例如隐藏式字幕、音量条和特技播放。 复制这些组件是浪费时间和精力； 集中和抽象代码的效率要高得多。

但请注意，共享组件通常不会像我们预期的那样重用，从而导致浪费精力。 因此，在集中组件之前要三思而后行。 如有疑问，请开始复制组件，并在几次迭代后，检查这些组件是否需要抽象。 错误的抽象比重复的代码要昂贵得多。

最后一层是托管 UI 组件库的微前端。 请记住微前端独立性的重要性。 当我们获得超过三个或四个外部依赖项时，我们正在走向分布式单体。 这是最糟糕的地方，因为我们将分布式架构视为我们想要摆脱的单体架构，不再在整个组织中创建独立团队。

为了确保我们在开发速度和独立团队以及 UI 一致性之间找到正确的权衡，请考虑在整个项目生命周期中每月或每两个月验证一次依赖项。 过去，我曾在公司工作，每两周在每个 sprint 结束时进行一次此练习，它帮助许多团队推迟了由于外部依赖项的阻碍而在 sprint 期间可能无法完成的任务。 这样，您将减少团队的挫败感并提高他们的绩效。

在技术方面，创建设计系统的最佳投资是 Web 组件。 由于您可以将 Web 组件与任何 UI 框架一起使用，因此如果您以后决定更改 UI 框架，设计系统将保持不变，从而节省您的时间和精力。 在某些情况下，使用 Web 组件是不可行的，例如必须针对旧浏览器的项目。 但是，您可能不会有如此强烈的要求，您可以针对现代浏览器，允许您在微前端架构中利用 Web 组件。

虽然准备好实施设计系统是工作的一半，但要在微前端架构中完成交付，您将需要一个坚实的治理来维持最初的投资。 请记住，处理分布式架构并不像您想象的那么简单。 通常，第一次实现非常顺利，因为有时间分配给它。 这些问题伴随着后续的更新而来。 尤其是当您与分布式团队打交道时，最好的方法是在持续集成 (CI) 阶段自动化系统设计版本验证。 每次构建微前端时，package.json 文件都应检查设计系统库是否为最新版本。

在 CI 中实施此检查可让您尽可能严格。 您可以决定在日志中提供警告，要求尽快更新版本，或者如果微前端落后一个或多个主要版本，则阻止创建工件。

一些公司有自定义仪表板来处理这个问题，不仅用于设计系统，还用于其他库，例如日志记录或身份验证。 这样，每个团队都可以实时检查他们的微前端是否实现了最新版本。

最后，让我们考虑一下团队的结构。传统上，在企业公司中，设计团队是集中的，负责设计系统的所有方面，从构思到交付，开发人员只需实现设计团队提供的库。然而，一些公司实施分布式模型，其中设计团队是一个中央权威，为整个设计系统提供核心组件和方向，但其他团队使用新组件或现有组件的新功能填充设计系统。在第二种方法中，我们通过允许开发团队为全球设计系统做出贡献来减少潜在的瓶颈。同时，我们设置了护栏，以确保每个组件都尊重整体计划，例如设计和开发之间的定期会议，设计团队可以指导开发团队的办公时间，甚至是设计团队确定方向的协作会议，但开发人员实际上是在设计系统中实现代码。


###  Developer Experience 开发者体验

对于垂直拆分的微前端，开发者的体验与 SPA 非常相似。但是，有一些建议您可能会觉得提前考虑很有用。首先，创建一个用于搭建微前端的命令行工具，其中包含您希望在所有微前端中共享的基本实现和通用库，例如日志库。虽然从一开始就不是必不可少的工具，但从长远来看，它绝对是有帮助的，尤其是对于新团队成员。此外，创建一个仪表板，总结您在不同环境中拥有的微前端版本。通常，您用于开发 SPA 的所有工具仍然与垂直拆分的微前端架构相关。我们将在第 7 章中更深入地讨论这个话题，在那里我们将回顾如何为微前端应用程序创建自动化管道。

###  Search Engine Optimization 搜索引擎优化

有些项目需要强大的 SEO 策略，包括微前端项目。让我们看一下具有垂直拆分微前端的良好 SEO 策略的两个主要选项。第一个涉及以爬虫可以轻松索引的方式优化应用程序代码。在这种情况下，开发人员的工作是实施尽可能多的最佳实践，以便及时（通常在 5 秒内）渲染整个 DOM。对于爬虫来说，时间很重要，因为它们必须对视图中的所有数据进行索引，并且还必须以一种公开所有有意义的信息而不隐藏在用户交互后面的方式来构建 UI。另一种选择是创建一个对爬虫有意义的 HTML 标记，以提取内容并对其进行正确分类。虽然这并非不可能，但从长远来看，这个选项可能需要一些努力来维护每个新功能和项目增强。

另一种选择是使用动态呈现为所有试图索引您的内容的爬虫提供优化版本的 Web 应用程序。 Google 引入了动态渲染，允许您将爬虫请求重定向到您网站的优化版本，通常是预渲染的，而不会影响您的网站在搜索引擎结果中的位置（见图 4-8）。

有几个解决方案可以将应用程序的预渲染版本提供给爬虫。首先，对于预渲染阶段，您可以创建网站的自定义版本，以获取用户将使用的网站的相同数据。例如，您可以创建存储在对象存储中的服务器端渲染输出，该输出在编译时将模板转换为静态 HTML 页面，保持相同的面向用户的 URL 结构。 Amazon S3 是一个不错的选择。您还可以决定在运行时进行服务器端渲染，从而无需存储静态页面并为爬虫提供专门为它们创建的即时版本。尽管此解决方案需要一些努力来实施，但它允许您进行最佳定制和优化，以改善对爬虫的最终输出。

第二种选择是使用 Puppeteer 或 Rendertron 等开源解决方案从为用户创建的网站中抓取代码，然后部署一个定期生成静态页面的 Web 服务器。

生成网站的静态版本后，您需要知道请求何时来自浏览器以及何时来自爬虫。一个基本的实现是使用一个正则表达式来识别爬虫的用户代理。一个很好的 Node.js 库是 crawler-user-agents。在这种情况下，在识别出用户代理头之后，应用服务器可以用正确的实现来响应。该解决方案可以使用 AWS Lambda@Edge 或 Cloudflare Workers 等技术在边缘应用。在这种情况下，一些云提供商的 CDN 在收到请求后允许计算层。因为这些容器的最大执行时间有一些限制，所以用户代理识别代表了使用这些边缘技术的一个很好的理由。此外，它们可以用于额外的逻辑，引入金丝雀版本或蓝绿部署，我们将在第 6 章中看到。

###  Performance and Micro-Frontends 性能和微前端

在微前端架构中是否可以获得良好的性能？确实！与任何其他前端架构一样，微前端架构的性能是 Web 应用程序成功的关键。由于域的拆分以及与客户端共享的代码，垂直拆分架构可以实现良好的性能。

想一想SPA。通常，用户必须下载与应用程序、业务逻辑和整个应用程序中使用的库特别相关的所有代码。为简单起见，假设整个应用程序代码为 500 KB。由登录、注册、登陆页面、客户支持和其他几个视图组成的未认证区域需要 100 KB 的业务逻辑，而认证区域需要 150 KB 的业务逻辑。两者都使用相同的捆绑依赖项，每个 250 KB（参见图 4-9）。

新用户必须下载所有 500 KB，尽管操作必须在 SPA 内完成。也许一个用户只想了解业务主张并仅访问登录页面，另一个用户想查看可用的支付方式，或者经过身份验证的用户主要对提供服务或产品的经过身份验证的区域感兴趣。无论用户试图实现什么，他们都被迫下载整个应用程序。

然而，在垂直拆分架构中，我们想要在登录页面上查看业务主张的未经身份验证的用户将能够仅为该微前端下载代码，而经过身份验证的用户将仅下载经过身份验证的区域的代码库.我们通常没有意识到我们的用户行为与我们解释应用程序的方式不同，因为我们经常从整体上优化应用程序的性能，而不是通过用户与网站的交互方式来优化。根据用户体验优化我们的网站会产生更好的结果。

将前面的示例应用于垂直拆分架构，仅对未认证区域感兴趣的用户将下载不到 100 KB 的业务逻辑和共享依赖项，而经过身份验证的用户将仅下载 250 KB 和共享依赖项。

显然，超出登录页面的新用户将下载近 500 KB，但如果我们正确识别应用程序边界，这种方法仍将节省一些 KB，因为新用户不太可能浏览每个应用程序视图。在最坏的情况下，用户将像下载 SPA 一样下载 500 KB，但这次不是预先下载所有内容。当然，由于应用程序外壳的原因，还有额外的逻辑要下载，但通常大小只有两位数，对于这个例子来说没有意义。图 4-10 展示了垂直拆分微前端在性能方面的优势。

在垂直拆分架构上管理性能的一个好做法是引入性能预算。性能预算是团队不允许超过的微前端限制。性能预算包括最终包大小、要加载的多媒体内容，甚至 CSS 文件。设置性能预算是确保每个团队正确优化自己的微前端的重要部分，甚至可以在 CI 过程中强制执行。直到项目后期才设置性能预算，但每次在微前端代码库中引入有意义的重构或附加功能时，都应该更新它。

向用户显示最终结果的时间是一个关键的性能指标，要跟踪的指标包括交互时间或首次内容绘制时间、最终工件的大小、字体大小和 JavaScript 包大小，以及诸如可访问性和 SEO。像 Lighthouse 这样的工具对于分析这些指标非常有用，并且可以在命令行版本中使用，以便在持续集成过程中使用。尽管这些指标已针对 SPA 优化进行了广泛讨论，但对于微前端而言，捆绑包的大小可能会更加棘手。

使用垂直拆分架构，您可以决定将所有共享库捆绑在一起，或者为每个微前端捆绑库。前者可以提供更高的性能，因为用户只下载一次捆绑包，但您需要协调库以针对所有微前端的每次更改进行更新。虽然这听起来像是一项简单的任务，但如果它经常发生，它可能比你想象的要复杂得多。想象一下，您对特定的共享 UI 框架进行了重大更改；在所有微前端都对新框架版本进行广泛测试之前，您无法更新新版本。因此，虽然我们在这种情况下获得了绩效，但我们必须首先克服一些组织挑战。后一种解决方案——独立维护每个微前端——减少了协调共享依赖项的通信开销，但可能会增加用户必须下载的内容。然而，如前所述，用户可能决定在整个会话期间都留在同一个微前端，从而下载完全相同的千字节。

再一次，这些策略都没有对错之分。对要满足的要求和您的操作环境做出决定。不要害怕拨打电话并监控用户如何与您的应用程序交互。您可能会发现，总体而言，您选择的解决方案尽管存在一些缺陷，但却是适合该项目的解决方案。请记住，您可以轻松地撤销此决定，因此请花适当的时间考虑您的项目需要哪条路径，但请注意，如果出现新需求或该决定弊大于利，您可以改变方向。

###  Available Frameworks 可用的框架

有一些框架可用于采用这种架构。但是，只要您将应用程序 shell 与任何微前端业务逻辑解耦，自行构建应用程序 shell 并不需要太多努力。使用域逻辑污染应用程序外壳代码库不仅是一种不好的做法，而且由于代码和逻辑耦合，从长远来看，可能会使使用微前端的所有努力和投资无效。

完全拥抱这种架构的两个框架是single-spa和qiankun。 single-spa 背后的概念非常简单：它是一个轻量级库，可为以下内容提供无差别的繁重工作：

#### Registration of micro-frontends 微前端注册

该库提供根配置以将微前端与系统的特定路径相关联。


####  Life cycle methods 生命周期方法

每个微前端在安装时都会暴露在多个阶段。 Single-spa 允许微前端为生命周期方法执行正确的任务。例如，当安装了微前端时，我们可以应用逻辑来获取 API。卸载后，我们应该移除所有监听器并清理所有 DOM 元素。


Single-spa 是一个成熟的库，经过多年的改进和生产中的许多集成。它是开源的并得到积极维护，背后有一个很棒的社区。在最新版本的库中，您也可以开发水平分割的微前端，包括服务器端渲染。乾坤建立在single-spa之上，增加了single-spa最新版本的一些功能。

考虑到挂载和卸载机制、依赖管理、微前端之间的编排以及许多其他功能已经可供使用，模块联合也可能是实现垂直拆分架构的一个很好的选择。模块联合通常用于在同一视图中组合多个微前端（水平拆分）。然而，没有什么能阻止我们使用它来处理垂直分割的微前端。而且，它是一个 webpack 插件。如果您的项目已经在使用 webpack，它可能会帮助您避免学习新的框架来组合和编排项目的微前端。在下一章中，我们将探索用于实现垂直和水平拆分架构的模块联合。

###  Use Cases 用例

当您的前端开发人员有 SPA 开发经验时，垂直拆分架构是一个很好的解决方案。它也会在一定程度上扩展，但如果您有数百名前端开发人员在同一个前端应用程序上工作，水平拆分可能更适合您的项目，因为您可以进一步模块化您的应用程序。

当您希望 UI 和 UX 保持一致时，垂直拆分架构也很棒。在这种情况下，每个团队都负责特定的业务领域，垂直拆分将允许他们开发端到端的体验，而无需与其他团队协调。

选择这种架构模式的另一个原因是您希望跨多个微前端的可重用性级别。例如，如果您主要重用设计系统的组件和一些库，如日志记录或支付，则垂直拆分可能是一个很好的架构适合。但是，如果您的微前端的一部分在多个视图中复制，则水平拆分可能是更好的解决方案。同样，让上下文驱动您的项目决策。

最后，当你开始接受微前端时，我首先推荐这种架构，因为它不会引入太多的复杂性。它为前端开发人员提供了平滑的学习曲线，将业务领域分发给了数十名前端开发人员没有任何问题，并且不需要大量的工具前期投资，但更普遍的是整个开发人员体验。

###  Architecture Characteristics 架构特点

#### 可部署性 Deployability  (5/5)

因为每个微前端都是一个 HTML 页面或一个 SPA，我们可以轻松地将我们的工件部署在云存储或应用服务器上，并在其前面粘贴一个 CDN。这是一种众所周知的方法，多年来被许多前端开发人员用于交付他们的 Web 应用程序。更好的是，当我们应用多 CDN 策略时，我们的无论 CDN 提供商可能有什么故障，内容都将始终提供给我们的用户。

####  Modularity 模块化 (2/5)

这种架构不是最模块化的。虽然我们有一定程度的模块化和可重用性，但更多的是在代码级别，共享组件或库，但在功能方面较少。例如，负责开发目录微前端的团队不太可能与另一个微前端共享它。此外，当我们因为新功能而不得不将垂直拆分的微前端拆分为两个或多个部分时，将需要更大的努力来解耦所有实现的共享依赖项，因为它被设计为一个独特的逻辑单元。

####  Simplicity 简单 (4/5)

考虑到这种方法的主要目的是减少团队的认知负担，并使用前端开发人员的知名实践来创建领域专家，这种简单性是内在的。没有太多的思维方式转变或新技术来学习接受这种架构。对于前端开发人员来说，从single-spa 或模块联合开始的开销应该是最小的。

与 SPA 相比，这种方法在应用程序外壳的端到端测试中显示出一些弱点。然而，除了这种极端情况，测试垂直分割的微前端并不代表对单元、集成或端到端测试的现有知识的挑战。

#### Performance 性能(4/5)

您可以共享用于垂直拆分架构的公共库，尽管它需要跨团队的最少协调。由于使用这种方法不太可能拥有数百个微前端，因此您可以轻松创建一个部署策略，将公共库与微前端业务逻辑分离，并在多个微前端之间保持通用性同步。与其他方法相比，例如服务器端渲染，下载微前端的代码存在延迟，因为应用程序外壳应该使用一些逻辑来初始化应用程序。当微前端过于复杂或多次往返服务器时，这可能会影响微前端的负载。

#### Developer experience  开发者经验 (4/5)

熟悉 SPA 工具的团队不需要转变思维方式来接受垂直拆分。在端到端测试期间可能存在一些挑战，但所有其他工程实践以及工具都保持不变。并非所有可用于 SPA 项目的工具都适合此架构，因此您的开发人员可能需要构建一些内部工具来填补空白。但是，可用的开箱即用工具应该足以开始开发，允许您的团队推迟决定构建新工具。

####  Scalability 可扩展性(5/5)

这种架构的可扩展性非常好，以至于当我们通过 CDN 提供静态内容时，我们甚至可以忘记它。我们还可以根据我们所服务的资产配置生存时间，为不经常变化的资产（如字体或供应商库）设置更长的时间，为经常变化的资产（如业务）设置较低的时间我们微前端的逻辑。这种架构几乎可以根据 CDN 容量无限扩展，这通常足以同时为数十亿用户提供服务。在某些情况下，当您绝对必须避免单点故障时，您甚至可以创建多 CDN 策略，其中您的微前端由多个 CDN 提供商提供服务。尽管更复杂，但它可以优雅地解决问题，而无需花费太多时间来创建自定义解决方案。

####  Coordination 协调 (4/5)

与其他架构相比，这种架构能够实现决策制定的高度去中心化，以及每个团队的自主权。通常，当域边界明确时，微前端之间的接触点是最小的。因此，除了用于定义应用程序外壳 API 并尽可能保持它们不知道域的初始投资外，不需要太多的协调。

表 4-1 收集了该微前端架构的架构特征及其相关分数。


##  Horizontal-Split Architectures 水平拆分架构

水平拆分架构为微前端应用程序的几乎所有需求提供了多种选择。由于可以在多个团队之间拆分任何视图的工作，这些架构具有非常精细的模块化水平。通过这种方式，您可以重用组织内多个团队构建的不同微前端来组合视图。水平拆分架构不仅适用于已经拥有相当规模的工程部门的公司，也适用于具有高水平代码可重用性的项目，例如多租户
企业对企业 (B2B) 项目，其中一位客户请求具有多个类别的定制或电子商务，行为和用户界面差异很小。您的团队可以轻松地为该客户和该域构建个性化的微前端。通过这种方式，我们降低了在应用程序的不同部分引入错误的风险，这要归功于每个微前端都应该保持的隔离和独立性。

同时，由于这种高度模块化，水平拆分架构是最具挑战性的实现之一，因为它需要可靠的治理和定期审查以获得微前端边界权利。此外，除非事先经过深思熟虑，否则这些架构会挑战组织的结构。对于这些架构，我们审查沟通流程和团队结构非常重要，以使开发人员能够完成他们的工作并避免团队之间过多的外部依赖。此外，我们需要分享最佳实践并定义要遵循的准则，以保持良好的自由度，同时为用户提供独特、统一的体验。

当我们使用水平拆分架构时，推荐的做法之一是减少同一视图中的微前端数量，尤其是当多个团队必须将他们的工作合并在一起时。这听起来很明显，但存在过度设计解决方案以使多个微小的微前端生活在同一个视图中的真正风险，这会产生反模式。这是因为您模糊了微前端和组件之间的界限，前者是子域的业务表示，后者是用于可重用目的的技术解决方案。

>   COMPONENTS VERSUS MICRO-FRONTENDS
>   组件与微前端
>   了解我们是构建组件还是微前端的一个很好的经验法则是，对于一个组件，我们倾向于针对不同的用例进行扩展，公开多个属性以覆盖不同场景的所有用例。相反，使用微前端，我们封装了逻辑，允许通过事件进行通信。

此外，在同一视图中管理多个团队的输出需要在软件开发生命周期的多个阶段进行额外的协调。过度设计页面的另一个迹象是从同一个 API 获取多个微前端。在这种情况下，很有可能您将视图的划分推得太远，需要重构。请记住，采用这些架构提供了强大的功能，因此我们有责任为项目做出正确的选择。在接下来的部分中，我们将回顾水平拆分架构的不同实现：客户端、边缘端和服务器端。

###  Client Side 客户端

水平拆分架构的客户端实现类似于垂直拆分架构，因为有一个应用程序外壳用于组成最终视图。关键区别在于，这里的视图由多个微前端组成，可以由相同或不同的团队开发。由于水平拆分的模块化特性，重要的是不要落入过多考虑组件的陷阱。相反，坚持商业观点。

#### Foundation team 基金会团队
该团队负责应用程序外壳和设计系统，与 UX 团队一起工作，但从技术角度来看。

####  Landing page team 登录页团队
登陆页面团队负责支持营销团队推广流媒体服务并创建所需的所有不同登陆页面。

####  Catalog team 目录团队
该团队负责用户可以点播视频的经过身份验证的区域。它与其他团队合作，为服务订阅者提供引人入胜的体验。

#### Playback experience team 播放体验团队
考虑到构建可在多个平台上使用的出色视频播放器的复杂性，该公司决定组建一个专门负责播放体验的团队。该团队负责视频播放器、视频分析、数字版权管理 (DRM) 的实施以及与未经授权用户的视频消费相关的其他安全问题。


在实现众多登陆页面之一时，三个团队负责呈现给每个用户的最终视图。基础团队提供应用程序外壳、页脚和页眉，并组成登录页面中的其他微前端。登陆页面团队提供流媒体服务产品，以及有关视频平台的其他详细信息。播放体验团队提供视频播放器，用于投放吸引新用户使用服务所需的广告。
图 4-11 显示了这些元素之间的关系。

该视图不需要微前端之间的特定通信，因此一旦加载应用程序外壳，它就会检索其他两个微前端并将组合视图提供给用户。当订阅者想要观看任何视频内容时，经过身份验证后，他们将看到包含视频播放器的目录（请参阅
图 4-12)。

在这种情况下，每次用户与图块交互以观看内容时，目录微前端都必须与播放微前端通信以提供用户选择的视频的ID。当必须显示错误时，目录团队负责为用户触发带有错误消息的模式。并且当播放必须触发错误时，需要将错误传达给目录微前端，然后将其显示在视图中。这意味着我们需要一种策略，使两个微前端保持独立，但在用户交互或发生错误时允许它们之间进行通信。

有很多策略可以解决这个问题，比如使用自定义事件或事件发射器，但我们将在本章后面讨论不同的方法。为什么这个例子没有特定的组合策略？主要是因为每个客户端架构都有自己的视图组合方式。此外，在这种情况下，我们将逐个架构地看到这样做的最佳实践。

您想发现水平拆分架构真正闪耀的地方吗？让我们在视频流媒体平台发布几个月后快进。产品团队要求提供未经身份验证的目录版本，以提高平台资产的可发现性，并向潜在客户提供最佳节目的预览。这归结为在没有播放体验的情况下提供类似的目录体验。产品团队还希望在登录页面上提供更多信息，以便用户可以就订阅服务做出明智的决定。在这种情况下，将需要基础团队、目录团队和登录页面团队来完成此请求（参见图 4-13）。

出于技术和协作的原因，发展 Web 应用程序绝非易事。有一种方法可以同时组合微前端，然后在同一个视图中将它们拼接在一起，
多个团队在不互相干扰的情况下进行协作，让每个人的生活变得更轻松，并使业务能够向任何方向快速发展。









