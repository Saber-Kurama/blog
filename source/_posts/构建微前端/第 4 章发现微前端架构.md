# 发现微前端架构
在上一章中，我们了解了决策框架，这是任何微前端架构的基础。在本章中，我们将回顾不同的架构选择，应用我们目前所学的知识。

## 应用微前端决策框架

决策框架可帮助您根据微前端项目的特点选择正确的方法（见图 4-1）。您的第一个决定将是在水平和垂直拆分之间


###  Vertical Split

垂直拆分提供的选择较少，而且由于习惯于编写单页应用程序 (SPA) 的前端开发人员很可能熟悉它们，因此图 4-1 仅显示了客户端的选择。当您的项目需要一致的用户界面演变和跨多个视图的流畅用户体验时，您会发现垂直拆分很有帮助。这是因为垂直拆分提供了最接近 SPA 的开发人员体验，因此工具、最佳实践和模式可用于微前端的开发。

尽管从技术上讲，您可以使用任何组合来服务垂直拆分的微前端，但到目前为止，所有探索的实现都有一个客户端组合，其中应用程序外壳负责安装和卸载微前端，给我们留下了一种组合方法可供选择从。微前端和应用程序外壳之间的关系始终是一对一的，因此应用程序外壳一次只加载一个微前端。您还需要使用客户端路由。路由通常分为两部分，全局路由用于加载由应用程序外壳处理的不同微前端（见图 4-2）。

尽管同一微前端内部视图之间的本地路由由微前端本身管理，但您将完全控制其中存在的视图的实现和演变，因为负责微前端的团队也是应用程序业务领域的主题专家（图 4-3）。

最后，为了实现一个垂直分割的微前端架构，应用程序外壳加载 HTML 或 JavaScript 作为入口点。应用程序外壳不应与其他微前端共享任何业务领域逻辑，并且应该与技术无关以允许未来的系统演进，因此您不希望使用任何特定的 UI 框架来构建应用程序外壳。如果您构建了自己的实现，请尝试使用 Vanilla JavaScript。

应用程序外壳始终存在于用户会话期间，因为它负责编排 Web 应用程序以及为微前端公开一些生命周期 API，以便在它们完全安装或卸载时做出反应。

当垂直拆分的微前端必须与其他微前端共享信息时，例如令牌或用户偏好，我们可以使用查询字符串来获取易失性数据，或者使用 Web 存储来获取令牌或用户偏好，类似于水平拆分的方式不同观点之间。

### Horizontal Split

当业务子域应该在多个视图中呈现时，水平拆分效果很好，因此子域的可重用性成为项目的关键；当搜索引擎优化是您项目的关键要求并且您想使用服务器端渲染方法时；当您的前端应用程序需要数十甚至数百名开发人员一起工作并且您必须更细化地拆分我们的子域时；或者当您在软件的特定部分有一个客户自定义的多租户项目时。

您将做出的下一个决定是在客户端、边缘端和服务器端组合之间做出决定。例如，当您的团队更熟悉前端生态系统或者当您的项目受到高流量和显着峰值的影响时，客户端是一个不错的选择。您将避免处理前端层的可扩展性挑战，因为您可以利用内容交付网络 (CDN) 轻松缓存微前端。

您可以对具有静态内容和高流量的项目使用边缘组合，以便将可扩展性挑战委托给 CDN 提供商，而不必在您的基础设施中处理它。正如我们在第 3 章中所讨论的，采用这种架构风格存在一些挑战，例如其复杂的开发人员体验以及并非所有 CDN 都支持它的事实。但是像没有个性化内容的在线目录这样的项目可能是这种方法的一个很好的候选者。

服务器端组合为我们提供了对输出的最大控制权，这对于高度索引的网站（例如新闻网站或电子商务）非常有用。对于需要出色性能指标的网站来说，它也是一个不错的选择，例如 PayPal 和 American Express，它们都使用服务器端组合。

接下来是您的路由策略。虽然您可以在技术上将任何路由应用于任何组合，但通常使用与您选择的组合模式相关的路由策略。例如，如果您选择客户端组合，大多数情况下，路由将发生在客户端级别。您可以在边缘使用计算逻辑（在 AWS 或 CloudFlare 中使用 Lambda@Edge）以避免金丝雀版本污染应用程序外壳的代码，或利用动态渲染向搜索引擎爬虫提供 Web 应用程序的优化版本能力。

另一方面，边缘合成将有一个与每个视图关联的 HTML 页面，因此每次用户加载新页面时，都会在 CDN 中合成一个新页面，CDN 将检索多个微前端来创建该页面最后的看法。最后，通过服务器端路由，应用服务器将知道哪个 HTML 模板与特定路由相关联；路由和组合发生在服务器端。

您的组合选择也将有助于缩小您构建微前端项目的技术解决方案。当您使用客户端组合和路由时，最好的实现选择是应用程序 shell 在同一个视图中加载多个微前端，例如，使用名为 Module Federation 的 webpack 插件、iframe 或 web 组件。

对于边缘组合，唯一可用的解决方案是使用边缘包含 (ESI)。随着云提供商扩展其边缘服务以提供更多计算和存储资源，我们看到了未来可能会改变的迹象。不过，目前，ESI 是唯一的选择。当您决定使用服务器端组合时，您可以为您的微前端应用程序使用服务器端包含 (SSI) 或众多 SSR 框架之一。请注意，SSR 将为您提供更大的灵活性并控制您的实施。

决策框架中缺少最后一个支柱：当微前端处于相同或不同视图时，它们将如何通信。这主要是因为当你选择水平拆分时，你必须避免跨微前端共享任何状态；这种方法是一种反模式。相反，您将使用第 3 章中提到的技术，例如事件发射器、自定义事件或使用发布/订阅 (pub/sub) 模式实现的反应流，以解耦微前端并保持它们的独立性.当您必须在不同视图之间进行通信时，您将使用查询字符串参数来共享易失性数据，例如产品标识符，以及用于持久数据的 Web 存储/cookie，例如用户令牌或本地用户设置。

>  观察者模式
 观察者模式（也称为发布/订阅模式）是一种行为设计模式，它定义了对象之间的一对多关系，这样，当一个对象更改其状态时，所有相关对象都会得到通知并自动更新。与对其状态感兴趣的其他对象具有一对多关系的对象称为主题或发布者。它的依赖对象称为观察者或订阅者。每当主题的状态发生变化时，观察者都会收到通知，然后他们会采取相应的行动。主体可以有任意数量的依赖观察者。


##  Architecture Analysis 架构分析

为了帮助您更好地为您的项目选择正确的架构，我们现在将分析技术实现，着眼于挑战和好处。我们将详细审查不同的实现，然后评估每种架构的特征。我们将为每个实现分析的特征：

Deployability  可部署性

在环境中部署微前端的可靠性和易用性。

Modularity  模块化

易于添加或删除微前端，易于与微前端托管的共享组件集成。

Simplicity  简单

易于理解或做事。如果一个软件被认为是简单的，那么它很可能被发现很容易理解和推理。

Testability 可测试性

软件工件在给定测试环境中支持测试的程度。如果软件工件的可测试性高，那么通过测试来发现系统中的故障就更容易了。

Performance 表现

微前端如何满足 Web Vitals 所描述的用户体验质量的指标，这是一个健康网站的基本指标。

Developer experience  开发者经验

开发人员在使用您的产品时所获得的体验，无论是客户端库、SDK、框架、开源代码、工具、API、技术还是服务。

Scalability 可扩展性

流程、网络、软件或组织增长和管理不断增长的需求的能力。

Coordination 协调

统一、整合或同步团队成员的努力，以便在追求共同目标的过程中提供统一的行动。


特征以五分制进行评分，一分表示特定的架构特征没有得到很好的支持，五分表示架构特征是架构模式中最强的特征之一。该分数表明哪种架构特征在所描述的每种方法中表现得更好。由于它们彼此之间的紧张关系，几乎不可能让所有特征在架构中完美地工作。我们的角色是找到适合我们必须构建的应用程序的权衡，因此决定创建一个评分机制来评估所有这些架构方法。

### 架构和权衡

正如我在本书其他地方所指出的，我坚信完美的架构并不存在。这总是一个权衡。权衡不仅是技术上的，还取决于业务需求和组织结构。现代建筑考虑了有助于最终结果的其他力量以及技术方面。我们必须认识到社会技术方面并针对我们所处的环境进行优化，而不是寻找“完美的架构”（不存在）或从另一个环境中借用架构而不研究它是否适合我们的环境。

在《软件架构基础》一书中，Neal Ford 和 Mark Richards 很好地强调了这些新的架构实践，并邀请读者针对“最不差”的架构进行优化。正如他们所说，“永远不要追求最好的架构，而要追求最不差的架构。”

在确定最终架构之前，请花时间了解您所处的环境、团队的结构以及团队之间的沟通流程。当我们忽略这些方面时，我们就有可能创建一个完全不适合我们公司的伟大技术主张。当我们阅读其他采用特定架构的公司的案例研究时，情况也是如此。我们需要了解公司的运作方式以及与我们公司的运作方式相比如何。案例研究通常侧重于公司如何解决特定问题，这可能与您的挑战和目标重叠，也可能不重叠。由您来确定案例研究的挑战是否与您自己的挑战相匹配。

广泛阅读并与社区中的不同人交谈，以了解某些决定背后的力量。花时间研究将帮助您避免做出错误的假设，并更加了解您所处的环境。

每个架构都针对解决特定的技术和组织挑战进行了优化，这就是为什么我们看到如此多的微前端方法。请记住：架构没有对错之分，只是根据您自己的环境进行的最佳权衡。

##  Vertical-Split Architectures 垂直拆分架构

对于垂直拆分架构，客户端组合、客户端路由和应用程序外壳，如上所述，对于具有构建 SPA 以首次涉足微前端的坚实背景的团队来说非常棒，因为开发经验将是最熟悉的。这
对于有前端背景的开发者来说，这可能也是进入微前端世界的最简单方式。

###  Application Shell

作为微前端应用程序的持久部分，应用程序外壳是请求应用程序时首先下载的内容。它将从头到尾引导用户会话，根据用户请求的端点加载和卸载微前端。在应用程序外壳中加载微前端的主要原因包括：

处理初始用户状态（如果有）

如果用户尝试通过深度链接访问经过身份验证的路由，但用户令牌无效，则应用程序外壳会将用户重定向到登录视图或登录页面。但是，只有第一次加载才需要此过程。之后，Web 应用程序经过身份验证的区域中的每个微前端都应管理保持用户身份验证或将用户重定向到未经身份验证页面的逻辑。

 
Retrieving global configurations 检索全局配置

需要时，应用程序外壳应首先获取包含在整个用户会话中使用的任何信息的配置，例如，如果应用程序根据国家/地区提供不同的体验，则用户所在的国家/地区。


Fetching the available routes and associated micro-frontends to load 获取要加载的可用路由和相关的微前端

为了避免不必要地部署应用程序外壳，路由配置应该在运行时与相关的微前端一起加载。这将保证对路由系统的控制，而无需多次部署应用程序外壳。


Setting logging, observability, or marketing libraries 设置日志记录、可观察性或营销库

因为这些库通常应用于整个应用程序，所以最好在应用程序 shell 级别实例化它们。


Handling errors if a micro-frontend cannot be loaded 如果无法加载微前端，则处理错误

有时，由于网络问题或系统中的错误，微前端无法访问。向应用程序外壳添加错误消息（例如 404 页面）或加载高可用性微前端以显示错误并向用户建议可能的解决方案是明智的，例如建议类似产品或要求他们稍后再来。


您可以通过在每个微前端中使用库而不是使用像应用程序外壳这样的编排器来获得类似的结果。但是，理想情况下，您只需要一个地方来管理这些事情。拥有多个库意味着确保它们在微前端之间始终保持同步，这需要更多的协调并增加整个过程的复杂性。与将库集中在应用程序外壳内相比，拥有多个库也会在部署阶段产生风险，在部署阶段会发生重大变化。

切勿在用户会话期间将应用程序外壳用作与微前端不断交互的层。应用程序外壳应仅用于边缘情况或初始化。将其用作微前端的共享层可能会导致微前端和应用程序外壳之间存在逻辑耦合，从而强制测试和/或重新部署应用程序中可用的所有微前端。这种情况也称为分布式单体，是开发人员最糟糕的噩梦。

在这种模式下，应用程序外壳一次只加载一个微前端。这意味着您不需要创建一种机制来封装微前端之间的冲突依赖项，因为不会有
库或 CSS 样式之间的任何冲突（见图 4-4），只要在卸载微前端时两者都从窗口对象中删除。

应用程序外壳只不过是一个简单的 HTML 页面，其逻辑包装在一个 JavaScript 文件中。某些 CSS 样式可能包含在应用程序外壳中，也可能不包含在初始加载体验中，例如用于显示像微调器这样的加载动画。每个微前端入口点都由包含单个视图的逻辑和样式的单个 HTML 页面或包含多个路由的小型 SPA 表示，这些路由包含允许用户使用应用程序的整个子域所需的所有逻辑，而无需新的需要加载的微前端。可以加载 JavaScript 文件作为微前端入口点，但在这种情况下，我们受到初始客户体验的限制，因为我们必须等到 JavaScript 文件被解释后才能将新元素添加到域对象模型中（DOM）。

当我们想要创建一致的用户体验同时为单个团队提供完全控制时，垂直拆分效果很好。一个明显的迹象表明，这可能是您的应用程序的正确方法，当您在多个视图中没有很多业务子域重复但应用程序的每个部分都可能由应用程序本身表示时。

当我们清楚地了解用户如何与应用程序交互时，识别微前端变得很容易。如果您使用 Google Analytics 等分析工具，您将可以访问这些信息。如果您没有此信息，则需要先获取它，然后才能确定如何构建架构、业务领域和您的组织。在这种架构下，微前端的可重用性不高，因此垂直拆分的微前端不太可能在同一个应用程序中被多次重用。

然而，在每个微前端中，我们都可以重用组件（想想设计系统），生成有助于避免过多重复的模块化。不过，微前端更有可能在同一家公司维护的不同应用程序中重复使用。想象一下，在多租户环境中，您必须开发多个平台，并且您希望拥有一个类似的用户界面，并针对每个平台的一部分进行一些自定义。您将能够重用垂直拆分的微前端，减少代码碎片并根据业务需求独立发展系统。

###  Challenges 挑战

当然，在实施阶段会遇到一些挑战，就像任何架构模式一样。除了特定领域的挑战之外，我们还会遇到一些共同的挑战，其中一些有直接的答案，而另一些则更多地取决于上下文。让我们看看四个主要挑战：共享状态、微前端组合、多框架方法以及架构的演变。

####  Sharing state

一般来说，当我们使用微前端时，我们面临的第一个挑战是如何在微前端之间共享状态。虽然我们不需要与垂直拆分架构共享太多信息，但这种需求仍然存在。

我们可能需要跨多个微前端共享的一些信息在通过 Web 存储存储时很好，例如用户播放的媒体的音量级别或最近用于编辑文档的字体。

当信息更敏感时，例如个人用户数据或身份验证令牌，我们需要一种方法从公共 API 检索此信息，然后在所有对此信息感兴趣的微前端共享。在这种情况下，在用户会话开始时加载的第一个微前端将检索此数据，并存储在带有检索时间戳的 Web 存储中。然后每个需要此数据的微前端都可以直接从 Web 存储中检索它，如果时间戳早于预设的时间量，则微前端可以再次请求数据。并且由于应用程序一次只加载一个微前端，并且每个微前端都可以访问所选的 Web 存储，因此没有强烈要求通过应用程序外壳将数据存储在 Web 存储中。

但是，假设您的应用程序严重依赖 Web 存储，并且您决定实施安全检查以验证可用空间或存储的消息类型。在这种情况下，您可能希望通过应用程序外壳创建一个抽象，该外壳将公开一个用于存储和检索数据的 API。这将集中数据验证发生的位置，为每个微前端提供有意义的错误，以防验证失败。

#### Composing micro-frontends  组成微前端

您有多种选择可以在应用程序外壳中组合垂直拆分的微前端。但是请记住，垂直分割的微前端仅在客户端组成和路由，因此我们仅限于浏览器标准为我们提供的内容。在客户端组成微前端有四种技术：

#####  ES modules

JavaScript 模块可用于将我们的应用程序拆分为较小的文件，以便在编译时或运行时加载，在现代浏览器中完全实现。这可以是在运行时使用标准组合微前端的可靠机制。要实现 ES 模块，我们只需在 script 标签中定义 module 属性，浏览器会将其解释为模块：

``` js
 <script type="module" src="catalogMFE.js"></script>
```

该模块将始终被延迟，并且可以实现跨域资源共享 (CORS) 身份验证。 ES 模块也可以在导入映射中为整个应用程序定义，允许我们使用语法在应用程序中导入模块。截至发布时，导入地图的主要问题是并非所有浏览器都支持它们。您将受限于 Google Chrome、Microsoft Edge（带有 Chromium 引擎）和最新版本的 Opera，从而限制了该解决方案的可行性。

#####  SystemJS

此模块加载器支持导入地图规范，这些规范在浏览器中本机不可用。这允许它们在 SystemJS 实现中使用，其中模块加载器库使实现与所有浏览器兼容。当我们希望我们的微前端在运行时加载时，这是一个方便的解决方案，因为它使用类似于导入地图的语法并允许 SystemJS 处理浏览器的 API 碎片。


#####  Module Federation

这是 webpack 5 中引入的一个插件，用于加载外部模块、库，甚至是另一个应用程序中的整个应用程序。该插件负责组合微前端所需的无差别繁重工作，包装微前端的范围并在不同微前端之间共享依赖关系或处理同一库的不同版本而不会出现运行时错误。开发人员的体验和实现非常流畅，看起来就像编写一个普通的 SPA。每个微前端都作为一个模块导入，然后以与 UI 框架的组件相同的方式实现。这个插件所做的抽象使得整个作曲挑战几乎完全无痛。

##### HTML解析

当微前端有一个由 HTML 页面表示的入口点时，我们可以使用 JavaScript 来解析 DOM 元素并将所需的节点附加到应用程序外壳的 DOM 中。最简单的 HTML 文档实际上只是一个具有自己定义的模式的 XML 文档。鉴于此，我们可以将微前端视为 XML 文档，并使用 DOMParser 对象将相关节点附加到 shell 的 DOM 中。在解析完微前端 DOM 之后，我们使用adoptNode 或cloneNode 方法附加DOM 节点。但是，使用 cloneNode 或采用节点不适用于 script 元素，因为浏览器不会评估 script 元素，所以在这种情况下，我们创建一个新的，传递在微前端的 HTML 页面中找到的源文件。创建新的脚本元素将触发浏览器全面评估与
这个元素。通过这种方式，您甚至可以简化微前端开发人员的体验，因为您的团队将提供知道初始 DOM 外观的最终结果。这种技术被一些框架使用，例如 qiankun，它允许 HTML 文档成为微前端的入口点。


在客户端组成的所有主要框架都实现了这些技术，有时您甚至可以选择。例如，对于单个 SPA，您可以使用 ES 模块、带有导入映射的 SystemJS 或模块联合。

所有这些技术都允许您实现静态或动态路由。在静态路由的情况下，您只需在代码中硬编码路径。使用动态路径，您可以从静态 JSON 文件中检索所有路由以在应用程序开始时加载，或者通过开发可由应用程序外壳使用的端点以及根据用户所在国家/地区应用逻辑的端点来创建更动态的东西或返回最终路由列表的语言。

####  Multiframework approach 多框架方法

将微前端用于多框架方法是一个有争议的决定，因为许多人认为这会迫使他们使用多个 UI 框架，例如 React、Angular、Vue 或 Svelte。但是对于以单体方式编写的前端应用程序而言，对于微前端也是如此。

尽管从技术上讲，您可以在 SPA 中实现多个 UI 框架，但它会产生性能问题和潜在的依赖冲突。这也适用于微前端，因此不建议为这种架构风格使用多框架实现。

相反，请遵循最佳实践，例如尽可能减少外部依赖项，仅导入您使用的内容，而不是可能增加最终 JavaScript 包的整个包。许多 JavaScript 工具实现了 tree-shaking 机制来帮助实现更小的包大小。

